{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Hi \u8a18\u9304\u4e00\u500b","title":"Home"},{"location":"#hi","text":"\u8a18\u9304\u4e00\u500b","title":"Hi"},{"location":"laradock/","text":"\u5728\u5beb Laravel \u4e4b\u524d\u7684\u74b0\u5883\u8a2d\u7f6e\u975e\u5e38\u7e41\u7463\uff0c\u800c\u4e14\u6700\u8fd1\u4e5f\u5728\u627e\u80fd\u5920\u8f15\u9b06\u67b6\u597d\u591a\u500b laravel \u5c08\u6848\u7684\u65b9\u6cd5\uff0c\u6240\u4ee5\u5c31\u4f86\u8a66\u8a66 Laradock\uff0c\u6709\u4e9b\u96f7\u6240\u4ee5\u9084\u662f\u8a18\u9304\u4e00\u4e0b git clone https://github.com/Laradock/laradock.git \u4fee\u6539 Laradock \u4e0b\u7684 .env cp env-example .env \u4f60\u5c08\u6848\u7684\u8def\u5f91 APP_CODE_PATH_HOST=/path/to/project APP_CODE_PATH_CONTAINER=/var/www \u5982\u6b64 /path/to/project \u6703\u5c0d\u61c9\u81f3 workspace \u7684 /var/www \uff0c\u5982\u679c\u4f60\u4e00\u6b21\u8981\u8dd1\u591a\u500b\u5c08\u6848\u53ef\u4ee5\u5c07\u4ed6\u5011\u90fd\u653e\u5230\u8a72\u8cc7\u6599\u593e\u4e0b Nginx .env NGINX_HOST_HTTP_PORT=80 NGINX_HOST_HTTPS_PORT=443 NGINX_SSL_PATH=./nginx/ssl/ nginx/sites \u4e0b\u7de8\u8f2f\u8a2d\u5b9a\u6a94 $ cp laravel.conf.example laravel.test.conf Mysql .env: MYSQL_USER , MYSQL_PASSWORD \u8981\u548c laravel \u4e0b\u7684 .env \u4e00\u6a23 MYSQL_DATABASE=dataset MYSQL_USER=default MYSQL_PASSWORD=secret MYSQL_ROOT_PASSWORD= laravel .env: DB_HOST \u6539\u70ba mysql DB_HOST=mysql \u5982\u679c\u4f60\u5e0c\u671b root \u5bc6\u78bc\u70ba\u7a7a\uff0c\u5728 docker-compose.yml \u4e2d\u65b0\u589e MYSQL_ALLOW_EMPTY_PASSWORD=true environment: - MYSQL_DATABASE=${MYSQL_DATABASE} - MYSQL_USER=${MYSQL_USER} - MYSQL_PASSWORD=${MYSQL_PASSWORD} - MYSQL_ALLOW_EMPTY_PASSWORD=true - MYSQL_ROOT_PASSWORD=${MYSQL_ROOT_PASSWORD} - TZ=${WORKSPACE_TIMEZONE} phpmyadmin .env: PMA_USER , PMA_PASSWORD \u8981\u548c laravel \u4e0b\u7684 .env \u4e00\u6a23 PMA_USER=default PMA_PASSWORD=secret PMA_ROOT_PASSWORD= ... PMA_PORT=8081 \u555f\u52d5 \u7b2c\u4e00\u6b21\u8dd1\u53ef\u80fd\u6703\u6709\u9ede\u4e45 docker-compose up -d nginx mysql phpmyadmin \u932f\u8aa4: \u9700\u8981\u5c07 docker \u66f4\u65b0\u5230\u6700\u65b0\u7248 Service 'mysql' failed to build: Please provide a source image with from prior to commit \u8a2d\u5b9a laravel \u7b49\u5230\u74b0\u5883\u90fd\u5f04\u597d\u5f8c\u5c31\u9032\u5165 container \u8a2d\u5b9a\u597d laravel project $ docker-compose exec workspace bash $ composer install ... migrate \u932f\u8aa41 php_network_getaddresses: getaddrinfo failed: nodename nor servname provided, or not known \u539f\u56e0\u662f\u672c\u5730\u4e0d\u77e5\u9053 mysql \u662f\u4ec0\u9ebc\uff0c\u9700\u8981\u6307\u5b9a DB_HOST \u70ba 127.0.0.1 $ env DB_HOST=127.0.0.1 php artisan migrate migrate \u932f\u8aa42 SQLSTATE[42000]: Syntax error or access violation: 1231 Variable 'sql_mode' can't be set to the value of 'NO_AUTO_CREATE_USER' \u9700\u8981\u4fee\u6539 laravel project \u7684 config/database.php\uff0c\u5c07 mysql \u7684 stict \u6539\u70ba false \u8dd1\u591a\u500b\u5c08\u6848 \u8981\u5c07\u591a\u500b project \u653e\u5230\u540c\u4e00\u53f0\u6a5f\u5668\u4e0a\u4e5f\u5f88\u7c21\u55ae\uff0c\u9996\u5148\u5728\u4f60\u7684 APP_CODE_PATH_HOST \u4e2d\u653e\u597d\u591a\u500b project /path/to/project - project1 - project2 \u7136\u5f8c\u53bb Laradock/nginx/sites \u4e0b\u591a\u5efa\u7acb\u591a\u500b\u8a2d\u5b9a\u64cb # project1.conf server { listen 80; listen [::]:80; server_name project1; root /var/www/project1/public; ... } # project2.conf server { listen 80; listen [::]:80; server_name project2; root /var/www/project2/public; ... } \u5982\u679c\u662f\u5728\u672c\u5730\u6e2c\u8a66\u5728 /etc/hosts \u52a0\u4e0a 127.0.0.1 project1 127.0.0.1 project2 \u518d\u4f86\u8981\u65b0\u589e\u591a\u500b database \uff0c\u4e0a\u7db2\u67e5\u4e86\u4e0b\u597d\u50cf\u6c92\u6709\u8f15\u9b06\u7684\u65b9\u6cd5\u53ef\u4ee5\u76f4\u63a5\u5efa\u7acb\u591a\u500b database\uff0c\u9700\u8981\u5728 Laradock/mysql/docker-entrypoint-initdb.d \u4e0b\u5beb\u8173\u672c\u8b93 container \u5efa\u7acb\u6642\u57f7\u884c\uff0c\u65e2\u7136\u90fd\u8981\u5728\u9019\u908a\u5beb\u8173\u672c\u4e86\uff0c\u4e7e\u8106\u6240\u6709\u6703\u7528\u5230\u7684\u8cc7\u6599\u5eab\u90fd\u5728\u9019\u908a\u8a2d\u5b9a\u597d\uff0c\u4e0a\u8ff0\u7684\u8a2d\u5b9a\u64cb\u5c31\u586b\u500b dummy database \u548c user # createdb.sql CREATE DATABASE IF NOT EXISTS `project1`; CREATE DATABASE IF NOT EXISTS `project2`; CREATE USER 'user1'@'%' IDENTIFIED BY 'user1'; CREATE USER 'user2'@'%' IDENTIFIED BY 'user2'; GRANT ALL ON `project1`.* TO 'user1'@'%'; GRANT ALL ON `project2`.* TO 'user2'@'%'; \u8a18\u5f97\u5728 mysql \u8a2d\u5b9a\u6709\u66f4\u52d5\u5f8c\u522a\u6389\u8cc7\u6599\u518d\u91cd\u5efa $ rm -Rf ~/.laradock/data/mysql \u5982\u6b64\u5c31\u67b6\u597d\u591a\u500b laravel \u5c08\u6848\u62c9\uff0c\u5982\u679c https \u9700\u8981\u6191\u8b49\u53ef\u4ee5\u4f7f\u7528 cerbot\uff0c\u6703\u81ea\u52d5\u5e6b\u4f60\u53bb letsencrypt \u7533\u8acb\u6191\u8b49\uff0c\u518d\u5c07 cerbot \u5b58\u653e\u6191\u8b49\u7684\u4f4d\u5740\u548c nginx \u9023\u901a\u5373\u53ef\u3002","title":"Laradock"},{"location":"laradock/#laradock-env","text":"cp env-example .env \u4f60\u5c08\u6848\u7684\u8def\u5f91 APP_CODE_PATH_HOST=/path/to/project APP_CODE_PATH_CONTAINER=/var/www \u5982\u6b64 /path/to/project \u6703\u5c0d\u61c9\u81f3 workspace \u7684 /var/www \uff0c\u5982\u679c\u4f60\u4e00\u6b21\u8981\u8dd1\u591a\u500b\u5c08\u6848\u53ef\u4ee5\u5c07\u4ed6\u5011\u90fd\u653e\u5230\u8a72\u8cc7\u6599\u593e\u4e0b","title":"\u4fee\u6539 Laradock \u4e0b\u7684 .env"},{"location":"laradock/#nginx","text":".env NGINX_HOST_HTTP_PORT=80 NGINX_HOST_HTTPS_PORT=443 NGINX_SSL_PATH=./nginx/ssl/ nginx/sites \u4e0b\u7de8\u8f2f\u8a2d\u5b9a\u6a94 $ cp laravel.conf.example laravel.test.conf","title":"Nginx"},{"location":"laradock/#mysql","text":".env: MYSQL_USER , MYSQL_PASSWORD \u8981\u548c laravel \u4e0b\u7684 .env \u4e00\u6a23 MYSQL_DATABASE=dataset MYSQL_USER=default MYSQL_PASSWORD=secret MYSQL_ROOT_PASSWORD= laravel .env: DB_HOST \u6539\u70ba mysql DB_HOST=mysql \u5982\u679c\u4f60\u5e0c\u671b root \u5bc6\u78bc\u70ba\u7a7a\uff0c\u5728 docker-compose.yml \u4e2d\u65b0\u589e MYSQL_ALLOW_EMPTY_PASSWORD=true environment: - MYSQL_DATABASE=${MYSQL_DATABASE} - MYSQL_USER=${MYSQL_USER} - MYSQL_PASSWORD=${MYSQL_PASSWORD} - MYSQL_ALLOW_EMPTY_PASSWORD=true - MYSQL_ROOT_PASSWORD=${MYSQL_ROOT_PASSWORD} - TZ=${WORKSPACE_TIMEZONE}","title":"Mysql"},{"location":"laradock/#phpmyadmin","text":".env: PMA_USER , PMA_PASSWORD \u8981\u548c laravel \u4e0b\u7684 .env \u4e00\u6a23 PMA_USER=default PMA_PASSWORD=secret PMA_ROOT_PASSWORD= ... PMA_PORT=8081","title":"phpmyadmin"},{"location":"laradock/#_1","text":"\u7b2c\u4e00\u6b21\u8dd1\u53ef\u80fd\u6703\u6709\u9ede\u4e45 docker-compose up -d nginx mysql phpmyadmin \u932f\u8aa4: \u9700\u8981\u5c07 docker \u66f4\u65b0\u5230\u6700\u65b0\u7248 Service 'mysql' failed to build: Please provide a source image with from prior to commit","title":"\u555f\u52d5"},{"location":"laradock/#laravel","text":"\u7b49\u5230\u74b0\u5883\u90fd\u5f04\u597d\u5f8c\u5c31\u9032\u5165 container \u8a2d\u5b9a\u597d laravel project $ docker-compose exec workspace bash $ composer install ... migrate \u932f\u8aa41 php_network_getaddresses: getaddrinfo failed: nodename nor servname provided, or not known \u539f\u56e0\u662f\u672c\u5730\u4e0d\u77e5\u9053 mysql \u662f\u4ec0\u9ebc\uff0c\u9700\u8981\u6307\u5b9a DB_HOST \u70ba 127.0.0.1 $ env DB_HOST=127.0.0.1 php artisan migrate migrate \u932f\u8aa42 SQLSTATE[42000]: Syntax error or access violation: 1231 Variable 'sql_mode' can't be set to the value of 'NO_AUTO_CREATE_USER' \u9700\u8981\u4fee\u6539 laravel project \u7684 config/database.php\uff0c\u5c07 mysql \u7684 stict \u6539\u70ba false","title":"\u8a2d\u5b9a laravel"},{"location":"laradock/#_2","text":"\u8981\u5c07\u591a\u500b project \u653e\u5230\u540c\u4e00\u53f0\u6a5f\u5668\u4e0a\u4e5f\u5f88\u7c21\u55ae\uff0c\u9996\u5148\u5728\u4f60\u7684 APP_CODE_PATH_HOST \u4e2d\u653e\u597d\u591a\u500b project /path/to/project - project1 - project2 \u7136\u5f8c\u53bb Laradock/nginx/sites \u4e0b\u591a\u5efa\u7acb\u591a\u500b\u8a2d\u5b9a\u64cb # project1.conf server { listen 80; listen [::]:80; server_name project1; root /var/www/project1/public; ... } # project2.conf server { listen 80; listen [::]:80; server_name project2; root /var/www/project2/public; ... } \u5982\u679c\u662f\u5728\u672c\u5730\u6e2c\u8a66\u5728 /etc/hosts \u52a0\u4e0a 127.0.0.1 project1 127.0.0.1 project2 \u518d\u4f86\u8981\u65b0\u589e\u591a\u500b database \uff0c\u4e0a\u7db2\u67e5\u4e86\u4e0b\u597d\u50cf\u6c92\u6709\u8f15\u9b06\u7684\u65b9\u6cd5\u53ef\u4ee5\u76f4\u63a5\u5efa\u7acb\u591a\u500b database\uff0c\u9700\u8981\u5728 Laradock/mysql/docker-entrypoint-initdb.d \u4e0b\u5beb\u8173\u672c\u8b93 container \u5efa\u7acb\u6642\u57f7\u884c\uff0c\u65e2\u7136\u90fd\u8981\u5728\u9019\u908a\u5beb\u8173\u672c\u4e86\uff0c\u4e7e\u8106\u6240\u6709\u6703\u7528\u5230\u7684\u8cc7\u6599\u5eab\u90fd\u5728\u9019\u908a\u8a2d\u5b9a\u597d\uff0c\u4e0a\u8ff0\u7684\u8a2d\u5b9a\u64cb\u5c31\u586b\u500b dummy database \u548c user # createdb.sql CREATE DATABASE IF NOT EXISTS `project1`; CREATE DATABASE IF NOT EXISTS `project2`; CREATE USER 'user1'@'%' IDENTIFIED BY 'user1'; CREATE USER 'user2'@'%' IDENTIFIED BY 'user2'; GRANT ALL ON `project1`.* TO 'user1'@'%'; GRANT ALL ON `project2`.* TO 'user2'@'%'; \u8a18\u5f97\u5728 mysql \u8a2d\u5b9a\u6709\u66f4\u52d5\u5f8c\u522a\u6389\u8cc7\u6599\u518d\u91cd\u5efa $ rm -Rf ~/.laradock/data/mysql \u5982\u6b64\u5c31\u67b6\u597d\u591a\u500b laravel \u5c08\u6848\u62c9\uff0c\u5982\u679c https \u9700\u8981\u6191\u8b49\u53ef\u4ee5\u4f7f\u7528 cerbot\uff0c\u6703\u81ea\u52d5\u5e6b\u4f60\u53bb letsencrypt \u7533\u8acb\u6191\u8b49\uff0c\u518d\u5c07 cerbot \u5b58\u653e\u6191\u8b49\u7684\u4f4d\u5740\u548c nginx \u9023\u901a\u5373\u53ef\u3002","title":"\u8dd1\u591a\u500b\u5c08\u6848"},{"location":"linux-kernel/prepare/","text":"\u7248\u672c ubuntu 16.04 linux-kernel 4.4.1 https://mirrors.edge.kernel.org/pub/linux/kernel/v4.x/ https://elixir.bootlin.com/linux/v4.4.100/source \u74b0\u5883 \u4e0b\u8f09\u5f8c\u5148\u89e3\u58d3\u7e2e $ tar zxvf linux-3.9.1.tar.gz \u7de8\u8b6f $ cd linux-3.9.1 $ make menuconfig # or make defconfig $ make clean $ make $ make modules_install install \u7b2c\u4e00\u6b21make\u6709\u5674 error: include/linux/compiler-gcc.h:106:30: fatal error: linux/compiler-gcc5.h\uff1aNo such file or directory \u628a\u7576\u524dkernel\u539f\u78bc\u4e2d\u7684gcc\u8907\u88fd\u5230\u8981\u7de8\u8b6f\u7684kernel\u88e1\u5373\u53ef https://blog.csdn.net/u014525494/article/details/53573298 $ file arch/x86/boot/bzImage arch/x86/boot/bzImage: Linux kernel x86 boot executable bzImage, version 3.9.1 (root@eugene) #0 SMP Sun Nov 17 22:21:14 CST 2019, RO-rootFS, swap_dev 0x5, Normal VGA Enable the kernel for boot(\u96d6\u7136\u597d\u50cf\u4ed6\u6703\u81ea\u5df1\u52a0) $ sudo update-initramfs -c -k 3.19 $ sudo update-grub \u7136\u5f8c\u76f4\u63a5\u7528\u9019\u500bkernel\u958b\u6a5f\u7684\u8a71\u6703\u5361\u5728 Uncompressing Linux... done, booting the kernel. \u4e0a\u7db2\u67e5\u4e86\u4e4b\u5f8c\u767c\u73fe\u53ef\u80fd\u7684\u539f\u56e0\u4e00\u5927\u5806\uff0c\u7d22\u6027\u76f4\u63a5\u63db\u4e863.10.1\u770b\u770b\u7d50\u679c\u9084\u662f\u4e00\u6a23 \u53e6\u5916\u767c\u73fe\u5728 make install \u548c update-initramfs \u7684\u6642\u5019\u6709\u5674 amd64-microcode unsupported kernel version \u6700\u5f8c\u6539\u62104.4.1(\u672c\u4f86\u7684kernel\u662f4.4.0)\u5c31\u597d\u4e86 \u958b\u6a5f\u4e4b\u5f8c\u78ba\u5b9a\u4f7f\u7528\u7684kernel\u662f\u6211\u5011\u525b\u525b\u7de8\u7684 $ uname -a Linux eugene 4.4.1 #1 SMP Mon Nov 18 14:36:16 CST 2019 x86_64 x86_64 x86_64 GNU/Linux \u6210\u529f! \u65b0\u589e\u4e00\u500bsystem call \u5148\u5efa\u7acb\u4e00\u500b\u7a0b\u5f0f\u88e1\u9762\u6709 sys_helloworld \u7684 function $ cd linux-4.4.1/ $ mkdir mycall $ vim helloworld.c #include <linux/kernel.h> asmlinkage int sys_helloworld(void){ printk(\"hello world\"); return 0; } \u5efa\u7acbMakefile $ vim Makefile obj-y := helloworld.o \u5728\u4e3b\u8981\u7684Makefile\u4e2d\u65b0\u589emycall\u8cc7\u6599\u593e\u9032\u53bb $ cd .. $ vim Makefile core-y += kernel/ certs/ mm/ fs/ ipc/ security/ crypto/ block/ mycall/ \u5728system call table\u88e1\u65b0\u589e\u6211\u5011\u7684system call $ vim arch/x86/entry/syscalls/syscall_64.tbl 546 64 helloworld sys_helloworld # \u5728\u6700\u5f8c\u9762\u4e00\u884c\u52a0\u4e0a \u4fee\u6539 system call header $ vim include/linux/syscalls.h # \u52a0\u5728#endif\u524d asmlinkage int helloworld(void); \u7de8\u8b6f $ sudo make $ sudo make modules_install install $ reboot \u6700\u5f8c\u5beb\u4e00\u500b\u7a0b\u5f0f\u6e2c\u8a66\u4e00\u4e0b #include <stdio.h> #include <syscall.h> #include <sys/types.h> int main(){ int a = syscall(546); printf(\"system call sys_hello_world return %d\\n\", a); return 0; } $ dmesg \u6709\u770b\u5230hello world\u5c31\u4ee3\u8868\u6210\u529f\u4e86 reference: https://chybeta.github.io/2017/10/19/Linux-kernel-development-1-\u73af\u5883\u51c6\u5907/ https://www.linux.com/tutorials/how-compile-linux-kernel-0/ https://wenyuangg.github.io/posts/linux/linux-add-system-call.html https://blog.kaibro.tw/2016/11/07/Linux-Kernel\u7de8\u8b6f-Ubuntu/?fbclid=IwAR0n1xjghssrijlA7L8nFhjojsu-Wdb8w25900l_WVtvDQeJgJzv7MaXxIU","title":"\u6e96\u5099"},{"location":"linux-kernel/prepare/#_1","text":"ubuntu 16.04 linux-kernel 4.4.1 https://mirrors.edge.kernel.org/pub/linux/kernel/v4.x/ https://elixir.bootlin.com/linux/v4.4.100/source","title":"\u7248\u672c"},{"location":"linux-kernel/prepare/#_2","text":"\u4e0b\u8f09\u5f8c\u5148\u89e3\u58d3\u7e2e $ tar zxvf linux-3.9.1.tar.gz \u7de8\u8b6f $ cd linux-3.9.1 $ make menuconfig # or make defconfig $ make clean $ make $ make modules_install install \u7b2c\u4e00\u6b21make\u6709\u5674 error: include/linux/compiler-gcc.h:106:30: fatal error: linux/compiler-gcc5.h\uff1aNo such file or directory \u628a\u7576\u524dkernel\u539f\u78bc\u4e2d\u7684gcc\u8907\u88fd\u5230\u8981\u7de8\u8b6f\u7684kernel\u88e1\u5373\u53ef https://blog.csdn.net/u014525494/article/details/53573298 $ file arch/x86/boot/bzImage arch/x86/boot/bzImage: Linux kernel x86 boot executable bzImage, version 3.9.1 (root@eugene) #0 SMP Sun Nov 17 22:21:14 CST 2019, RO-rootFS, swap_dev 0x5, Normal VGA Enable the kernel for boot(\u96d6\u7136\u597d\u50cf\u4ed6\u6703\u81ea\u5df1\u52a0) $ sudo update-initramfs -c -k 3.19 $ sudo update-grub \u7136\u5f8c\u76f4\u63a5\u7528\u9019\u500bkernel\u958b\u6a5f\u7684\u8a71\u6703\u5361\u5728 Uncompressing Linux... done, booting the kernel. \u4e0a\u7db2\u67e5\u4e86\u4e4b\u5f8c\u767c\u73fe\u53ef\u80fd\u7684\u539f\u56e0\u4e00\u5927\u5806\uff0c\u7d22\u6027\u76f4\u63a5\u63db\u4e863.10.1\u770b\u770b\u7d50\u679c\u9084\u662f\u4e00\u6a23 \u53e6\u5916\u767c\u73fe\u5728 make install \u548c update-initramfs \u7684\u6642\u5019\u6709\u5674 amd64-microcode unsupported kernel version \u6700\u5f8c\u6539\u62104.4.1(\u672c\u4f86\u7684kernel\u662f4.4.0)\u5c31\u597d\u4e86 \u958b\u6a5f\u4e4b\u5f8c\u78ba\u5b9a\u4f7f\u7528\u7684kernel\u662f\u6211\u5011\u525b\u525b\u7de8\u7684 $ uname -a Linux eugene 4.4.1 #1 SMP Mon Nov 18 14:36:16 CST 2019 x86_64 x86_64 x86_64 GNU/Linux \u6210\u529f!","title":"\u74b0\u5883"},{"location":"linux-kernel/prepare/#system-call","text":"\u5148\u5efa\u7acb\u4e00\u500b\u7a0b\u5f0f\u88e1\u9762\u6709 sys_helloworld \u7684 function $ cd linux-4.4.1/ $ mkdir mycall $ vim helloworld.c #include <linux/kernel.h> asmlinkage int sys_helloworld(void){ printk(\"hello world\"); return 0; } \u5efa\u7acbMakefile $ vim Makefile obj-y := helloworld.o \u5728\u4e3b\u8981\u7684Makefile\u4e2d\u65b0\u589emycall\u8cc7\u6599\u593e\u9032\u53bb $ cd .. $ vim Makefile core-y += kernel/ certs/ mm/ fs/ ipc/ security/ crypto/ block/ mycall/ \u5728system call table\u88e1\u65b0\u589e\u6211\u5011\u7684system call $ vim arch/x86/entry/syscalls/syscall_64.tbl 546 64 helloworld sys_helloworld # \u5728\u6700\u5f8c\u9762\u4e00\u884c\u52a0\u4e0a \u4fee\u6539 system call header $ vim include/linux/syscalls.h # \u52a0\u5728#endif\u524d asmlinkage int helloworld(void); \u7de8\u8b6f $ sudo make $ sudo make modules_install install $ reboot \u6700\u5f8c\u5beb\u4e00\u500b\u7a0b\u5f0f\u6e2c\u8a66\u4e00\u4e0b #include <stdio.h> #include <syscall.h> #include <sys/types.h> int main(){ int a = syscall(546); printf(\"system call sys_hello_world return %d\\n\", a); return 0; } $ dmesg \u6709\u770b\u5230hello world\u5c31\u4ee3\u8868\u6210\u529f\u4e86 reference: https://chybeta.github.io/2017/10/19/Linux-kernel-development-1-\u73af\u5883\u51c6\u5907/ https://www.linux.com/tutorials/how-compile-linux-kernel-0/ https://wenyuangg.github.io/posts/linux/linux-add-system-call.html https://blog.kaibro.tw/2016/11/07/Linux-Kernel\u7de8\u8b6f-Ubuntu/?fbclid=IwAR0n1xjghssrijlA7L8nFhjojsu-Wdb8w25900l_WVtvDQeJgJzv7MaXxIU","title":"\u65b0\u589e\u4e00\u500bsystem call"},{"location":"linux-kernel/project-1-check/","text":"","title":"Project 1 \u6aa2\u8a0e"},{"location":"linux-kernel/project-1/","text":"Add a new system call void linux_survey_TT(char *) to your Linux kernel so that you can call it in your program The system call has a parameter which specifies the address of a memory area that can store all information the system call collects in the kernel. The system call records the virtual address intervals consisting of the user address space of the process executing the system call. The system call records the corresponding physical address intervals used by the above virtual address intervals at the moment that you execute system call void linux_survey_TT(). 1. \u6211\u5011\u8981\u53d6\u5f97\u547c\u53eb\u6b64 system call \u7684 process \u7684 virtual address intervals\uff0c\u800c\u6211\u5011\u7684\u76ee\u6a19\u5c31\u662f\u53bb\u6293current\u88e1\u9762\u7684mm_struct\u7269\u4ef6 Linux kernel \u4e2d\u9032\u7a0b\u7528 task_struct \u7d50\u69cb\u9ad4\u8868\u793a \u9032\u7a0b\u4e3b\u8981\u7531\u4ee5\u4e0b\u5e7e\u90e8\u5206\u7d44\u6210\uff1a \u4ee3\u78bc\u6bb5\uff1a\u7de8\u8b6f\u5f8c\u5f62\u6210\u7684\u4e00\u4e9b\u6307\u4ee4 \u6578\u64da\u6bb5\uff1a\u7a0b\u5e8f\u904b\u884c\u6642\u9700\u8981\u7684\u6578\u64da \u53ea\u8b80\u6578\u64da\u6bb5\uff1a\u5e38\u91cf \u5df2\u521d\u59cb\u5316\u6578\u64da\u6bb5\uff1a\u5168\u5c40\u8b8a\u91cf\uff0c\u975c\u614b\u8b8a\u91cf \u672a\u521d\u59cb\u5316\u6578\u64da\u6bb5\uff08bss)\uff1a\u672a\u521d\u59cb\u5316\u7684\u5168\u5c40\u8b8a\u91cf\u548c\u975c\u614b\u8b8a\u91cf \u5806\u68e7\u6bb5\uff1a\u7a0b\u5e8f\u904b\u884c\u6642\u52d5\u614b\u5206\u914d\u7684\u4e00\u4e9b\u5167\u5b58 PCB\uff1a\u9032\u7a0b\u4fe1\u606f\uff0c\u72c0\u614b\u6a19\u8b58\u7b49 struct task_struct { volatile long state; //\u8fdb\u7a0b\u72b6\u6001 struct mm_struct *mm, *active_mm; //\u5185\u5b58\u5730\u5740\u7a7a\u95f4 pid_t pid; pid_t tgid; struct task_struct __rcu *real_parent; //\u771f\u6b63\u7684\u7236\u8fdb\u7a0b\uff0cfork\u65f6\u8bb0\u5f55\u7684 struct task_struct __rcu *parent; // ptrace\u540e\uff0c\u8bbe\u7f6e\u4e3atrace\u5f53\u524d\u8fdb\u7a0b\u7684\u8fdb\u7a0b struct list_head children; //\u5b50\u8fdb\u7a0b struct list_head sibling; //\u7236\u8fdb\u7a0b\u7684\u5b50\u8fdb\u7a0b\uff0c\u5373\u5144\u5f1f\u8fdb\u7a0b struct task_struct *group_leader; //\u7ebf\u7a0b\u7ec4\u7684\u9886\u5934\u7ebf\u7a0b char comm[TASK_COMM_LEN]; //\u8fdb\u7a0b\u540d\uff0c\u957f\u5ea6\u4e0a\u9650\u4e3a16\u5b57\u7b26 struct fs_struct *fs; //\u6587\u4ef6\u7cfb\u7edf\u4fe1\u606f struct files_struct *files; // \u6253\u5f00\u7684\u6587\u4ef6 struct signal_struct *signal; struct sighand_struct *sighand; struct sigpending pending; void *stack; // \u6307\u5411\u5185\u6838\u6808\u7684\u6307\u9488 ... } \u800c\u5176\u4e2dmm_struct\u9577\u9019\u6a23 struct mm_struct { struct vm_area_struct * mmap; /* list of VMAs */ struct rb_root mm_rb; unsigned long mmap_base; /* base of mmap area */ unsigned long task_size; /* size of task vm space */ pgd_t * pgd; atomic_t mm_count; /* How many references to \"struct mm_struct\" (users count as 1) */ int map_count; /* number of VMAs */ unsigned long start_code, end_code, start_data, end_data; unsigned long start_brk, brk, start_stack; unsigned long arg_start, arg_end, env_start, env_end; struct file *exe_file; /* ... some code omitted ... */ }; \u5176\u4e2d\u6709\u95dcvirtual address intervals\u7684\u8cc7\u8a0a: unsigned long start_code, end_code, start_data, end_data; unsigned long start_brk, brk, start_stack; unsigned long arg_start, arg_end, env_start, env_end; \u9019\u4e9b\u8b8a\u6578\u5b58\u7684\u662fprocess memory layout\u4e2d\u500b\u5340\u584a\u7684\u8d77\u59cb, \u7d50\u675f\u4f4d\u5740\uff0c\u4f8b\u5982text segments\u5c31\u662fstart_code ~ end_code struct vm_area_struct * mmap; mmap\u7d00\u9304\u9032\u7a0b\u4f7f\u7528\u5230\u7684VMA\u5011 \u5176\u4e2dvm_area_struct\u4e2d\u6bd4\u8f03\u91cd\u8981\u7684\u8cc7\u6599\u6709 unsigned long vm_start\uff1a\u8a18\u9304\u6b64 VMA \u5340\u584a\u7684\u958b\u59cb\u4f4d\u5740 unsigned long vm_end\uff1a\u8a18\u9304\u6b64 VMA \u5340\u584a\u7684\u7d50\u675f\u4f4d\u5740 struct vm_area_struct *vm_next\uff1a\u6307\u5411\u4e0b\u4e00\u500b VMA \u5340\u584a\u7d50\u69cb\u7684\u6307\u6a19 \u6211\u731c\u6240\u6709VMA\u7684\u4f4d\u5740\u5c31\u662fprocess\u7684virtual address intervals\u4e86\u5427! void my_copy(char *result, unsigned long address, size_t length){ if(copy_to_user(result, &address, length)) printk(\"error while copy_to_user\\n\"); } while(mmap->vm_next != NULL){ my_copy(result, mmap->vm_start, length); result += length; my_copy(result, mmap->vm_end, length); result += length; mmap = mmap->vm_next; } my_copy(result, state_end, length); result += length; result += length; \u9019\u908a\u5728\u505a\u7684\u4e8b\u5c31\u662f\u628a\u6bcf\u4e00\u500bvma\u7684vm_start\u548cvm_end\u642c\u5230result\uff0c\u642c\u904e\u53bb\u4e4b\u5f8c\u518d\u5c07result\u5f80\u5f8clength(sizeof(unsigned long))\u500bbytes \u7531\u65bc\u6211\u662f\u6bcf\u500b\u5169\u500baddress\u70ba\u4e00\u7d44\uff0c\u6240\u4ee5\u6700\u5f8cstate_end\u6211\u4e5f\u4fdd\u7559\u5169\u500b\u8b8a\u6578\u7684\u4f4d\u5740 2. \u518d\u4f86\u6211\u5011\u8981\u53d6\u5f97corresponding physical address intervals \u7406\u89e3linux paging\u5c31\u5f88\u597d\u627e\u4e86 #include <linux/kernel.h> #include <linux/sched.h> #include <asm/pgtable.h> static unsigned long vaddr2paddr(unsigned long vaddr){ pgd_t *pgd; pud_t *pud; pmd_t *pmd; pte_t *pte; unsigned long paddr=0, page_addr=0, page_offset=0; pgd = pgd_offset(current->mm, vaddr); if (pgd_none(*pgd)) { printk(\"not mapped in pgd\\n\"); return -1; } pud = pud_offset(pgd, vaddr); if (pud_none(*pud)) { printk(\"not mapped in pud\\n\"); return -1; } pmd = pmd_offset(pud, vaddr); if (pmd_none(*pmd)) { printk(\"not mapped in pmd\\n\"); return -1; } pte = pte_offset_kernel(pmd, vaddr); if (pte_none(*pte)) { printk(\"not mapped in pte\\n\"); return -1; } page_addr = pte_val(*pte) & PAGE_MASK; page_offset = vaddr & ~PAGE_MASK; paddr = page_addr | page_offset; return paddr; } \u900f\u904epgd_offset, pud_offset, pmd_offset, pte_offset_kernel\u53d6\u5f97page table\uff0c\u518d\u914d\u5408PAGE_MASK\u53d6\u5f97physical address\uff0c\u5176\u4e2d\u4e26\u4e0d\u662f\u6bcf\u500bvirtual address\u90fd\u6709\u5206\u914d\u5230physical address\uff0c\u6240\u4ee5\u53ef\u80fd\u5728\u53d6\u67d0\u7d1a\u5206\u9801\u6642\u767c\u751f\u53d6\u4e0d\u5230\u7684\u72c0\u6cc1\uff0c\u6b64\u6642\u6211\u5011\u5c31\u53ef\u4ee5\u5224\u65b7\u8a72virtual address\u6c92\u6709\u88ab\u5206\u914d\u5230 mmap = mm->mmap; while(mmap->vm_next != NULL){ for(i=mmap->vm_start ; i<=mmap->vm_end ; i+=(~PAGE_MASK)+1){ unsigned long page_start = i, page_end = i+(~PAGE_MASK); unsigned long frame_start = vaddr2paddr(page_start), frame_end = vaddr2paddr(page_end); if(frame_start){ my_copy(result, page_start, length); result += length; my_copy(result, page_end, length); result += length; my_copy(result, frame_start, length); result += length; my_copy(result, frame_end, length); result += length; } } my_copy(result, vma_end, length); result += length; result += length; result += length; result += length; mmap = mmap->vm_next; } my_copy(result, state_end, length); result += length; result += length; result += length; result += length; \u7531\u65bcvirtual address\u5c0d\u5230physical address\u662f\u4ee5page\u70ba\u55ae\u4f4d\uff0c\u4e5f\u5c31\u662f\u8aaa\u4e00\u584apage\u7684\u8d77\u59cb\u4f4d\u7f6e\u6709\u5c0d\u61c9\u7684physical address\u5247\u4ee3\u8868\u6574\u584apage\u90fd\u6709\uff0c\u6240\u4ee5\u6211\u5c31\u905e\u8ff4\u904e\u6bcf\u500bvma\u4e2d\u7684\u6bcf\u500bpage \u9019\u908a\u6211\u662f\u4ee5\u6bcf\u56db\u500b\u8cc7\u6599\u70ba\u4e00\u7d44(page\u982d\u5c3e+frame\u982d\u5c3e)\uff0c\u96d6\u7136\u9019\u9ebc\u591aresult+=length\u6709\u9ede\u919c\u4e0d\u904e\u6211\u61f6\u5f97\u7528\u5176\u4ed6\u65b9\u6cd5\u4e86 3. \u5217\u51fa\u547c\u53ebsystem call\u6642\u6709\u591a\u5c11virtual address\u6709\u5c0d\u61c9\u7684physical address\uff08\u5e7e\u8db4\uff09 \u6211\u9019\u908a\u6e2c\u8a66\u7aef\u6309\u7167\u525b\u525b\u7684\u5132\u5b58\u65b9\u5f0f\u6293\u51fa 1 . virtual address intervals \u9019\u6642\u53ef\u4ee5\u9806\u4fbf\u8a08\u7b97virtual address\u7e3d\u6578 int virtual_cnt = 0, physical_cnt = 0; const int length = sizeof(unsigned long); for(int i=0 ; ; i++) { unsigned long vm_start, vm_end; memcpy(&vm_start, result, length); next memcpy(&vm_end, result, length); next if(vm_start == STATE_END) break; virtual_cnt += (vm_end - vm_start); fprintf(pfile, \"vma%d: 0x%lx ~ 0x%lx\\n\", i+1, vm_start, vm_end); } 2 . physical address intervals \u9806\u4fbf\u7b97\u51faphysical address\u7e3d\u6578 fprintf(pfile, \"physical address intervals: \\n\"); for(int i=0 ; ; ){ unsigned long page_start, page_end, frame_start, frame_end; memcpy(&page_start, result, length); next memcpy(&page_end, result, length); next memcpy(&frame_start, result, length); next memcpy(&frame_end, result, length); next if(page_start == STATE_END) break; if(page_start == VMA_END){ // fprintf(pfile, \"\\n\"); continue; } physical_cnt += MASK; i++; fprintf(pfile, \"0x%lx ~ 0x%lx -> 0x%lx ~ 0x%lx\\n\", page_start, page_end, frame_start, frame_end); } \u5176\u4e2d\u6211\u9019\u908a\u628aresult+=length\u66ff\u63db\u6210next\uff0c\u9084\u662f\u6c92\u591a\u597d\u770bqq 3 . \u5370\u51fa printf(\"%s virtual addresses that have physical memory: %.2f% \\n\", filename, (double)physical_cnt/virtual_cnt*100); 4. \u5370\u51fa\u54ea\u4e9bvirtual address intervals\u5c0d\u61c9\u5230\u76f8\u540c\u7684physical address intervals \u9019\u88e1\u5c31\u6709\u9ede\u9ebb\u7169\u4e86\uff0c\u7531\u65bcfork()\u5f8c\u8b8a\u6210\u5169\u500bprocess\u4e0d\u80fd\u76f4\u63a5\u628a\u8cc7\u6599\u5b58\u5230\u8b8a\u6578\u4e2d(child\u5b58\u7684parent\u770b\u4e0d\u5230)\uff0c\u6240\u4ee5\u5fc5\u9808\u8981\u518d\u8b80\u6a94\u6848\u4f86\u5206\u6790\uff0c\u8d85\u9ebb\u7169\u554a\u554a\u554a\u554a\u554a\u554a\u554a \u5148\u5ba3\u544a\u4e00\u500bstruct\u4f86\u5b58\u6211\u5011\u8981\u7684\u8cc7\u6599 struct page{ unsigned long page_start; unsigned long frame_start; }; \u8b80\u6a94\u5f8c\u5b58\u5728\u9663\u5217\u4e2d void analyze_file(char *filename, struct page *pages){ FILE *pfile; pfile = fopen(filename, \"r\"); if(!pfile){ printf(\"open file error!\\n\"); return; } // \u5148\u6293\u6389\u524d\u9762\u7684vma list char useless[100]; while(fscanf(pfile, \"%[^\\n]\", useless) != EOF && strcmp(useless, \"physical address intervals: \")) fscanf(pfile, \"\\n\", useless); fscanf(pfile, \"%[^\\n]\", useless); fscanf(pfile, \"\\n\", useless); // \u6211\u5011\u8981\u7684\u8cc7\u8a0a unsigned long page_start, page_end, frame_start, frame_end; int i=0; while(fscanf(pfile, \"0x%lx ~ 0x%lx -> 0x%lx ~ 0x%lx\\n\", &page_start, &page_end, &frame_start, &frame_end) != EOF){ pages[i].page_start = page_start; pages[i].frame_start = frame_start; i++; } fclose(pfile); } \u6700\u5f8c\u518d\u5206\u5225\u62ff\u5169\u500bchild\u7684result\u505a\u6bd4\u5c0d\uff08\u6211\u5c31\u76f4\u63a5\u66b4\u641c\u4e86\uff09 void calc_phy_relation(struct page *child, struct page *parent, int num){ printf(\"\\n\\nthe virtual address intervals that map to same physical address at result_%d\\n\", num); for(int i=0 ; i<300 ; i++){ if(!child[i].page_start && !child[i].frame_start) break; for(int j=0 ; j<300 ; j++){ if(!parent[j].page_start && !parent[j].frame_start) break; if(child[i].frame_start == parent[j].frame_start){ printf(\"0x%lx ~ 0x%lx\\n\", child[i].page_start, child[i].page_start+MASK-1); break; } } } } \u5b8c\u6210\u62c9\uff5e\uff5e\u5176\u5be6\u9ebb\u7169\u7684\u90fd\u5728\u8cc7\u6599\u8655\u7406 reference: http://gityuan.com/2017/07/30/linux-process/ https://www.cnblogs.com/kwingmei/p/3731746.html https://www.cnblogs.com/Rofael/archive/2013/04/13/3019153.html https://www.ffutop.com/posts/2019-07-17-understand-kernel-13/ https://stackoverflow.com/questions/5748492/is-there-any-api-for-determining-the-physical-address-from-virtual-address-in-li http://www.jollen.org/blog/2007/01/process_vma.html","title":"Project 1"},{"location":"linux-kernel/project-1/#1-system-call-process-virtual-address-intervalscurrentmm_struct","text":"","title":"1. \u6211\u5011\u8981\u53d6\u5f97\u547c\u53eb\u6b64 system call \u7684 process \u7684 virtual address intervals\uff0c\u800c\u6211\u5011\u7684\u76ee\u6a19\u5c31\u662f\u53bb\u6293current\u88e1\u9762\u7684mm_struct\u7269\u4ef6"},{"location":"linux-kernel/project-1/#linux-kernel-task_struct","text":"\u9032\u7a0b\u4e3b\u8981\u7531\u4ee5\u4e0b\u5e7e\u90e8\u5206\u7d44\u6210\uff1a \u4ee3\u78bc\u6bb5\uff1a\u7de8\u8b6f\u5f8c\u5f62\u6210\u7684\u4e00\u4e9b\u6307\u4ee4 \u6578\u64da\u6bb5\uff1a\u7a0b\u5e8f\u904b\u884c\u6642\u9700\u8981\u7684\u6578\u64da \u53ea\u8b80\u6578\u64da\u6bb5\uff1a\u5e38\u91cf \u5df2\u521d\u59cb\u5316\u6578\u64da\u6bb5\uff1a\u5168\u5c40\u8b8a\u91cf\uff0c\u975c\u614b\u8b8a\u91cf \u672a\u521d\u59cb\u5316\u6578\u64da\u6bb5\uff08bss)\uff1a\u672a\u521d\u59cb\u5316\u7684\u5168\u5c40\u8b8a\u91cf\u548c\u975c\u614b\u8b8a\u91cf \u5806\u68e7\u6bb5\uff1a\u7a0b\u5e8f\u904b\u884c\u6642\u52d5\u614b\u5206\u914d\u7684\u4e00\u4e9b\u5167\u5b58 PCB\uff1a\u9032\u7a0b\u4fe1\u606f\uff0c\u72c0\u614b\u6a19\u8b58\u7b49 struct task_struct { volatile long state; //\u8fdb\u7a0b\u72b6\u6001 struct mm_struct *mm, *active_mm; //\u5185\u5b58\u5730\u5740\u7a7a\u95f4 pid_t pid; pid_t tgid; struct task_struct __rcu *real_parent; //\u771f\u6b63\u7684\u7236\u8fdb\u7a0b\uff0cfork\u65f6\u8bb0\u5f55\u7684 struct task_struct __rcu *parent; // ptrace\u540e\uff0c\u8bbe\u7f6e\u4e3atrace\u5f53\u524d\u8fdb\u7a0b\u7684\u8fdb\u7a0b struct list_head children; //\u5b50\u8fdb\u7a0b struct list_head sibling; //\u7236\u8fdb\u7a0b\u7684\u5b50\u8fdb\u7a0b\uff0c\u5373\u5144\u5f1f\u8fdb\u7a0b struct task_struct *group_leader; //\u7ebf\u7a0b\u7ec4\u7684\u9886\u5934\u7ebf\u7a0b char comm[TASK_COMM_LEN]; //\u8fdb\u7a0b\u540d\uff0c\u957f\u5ea6\u4e0a\u9650\u4e3a16\u5b57\u7b26 struct fs_struct *fs; //\u6587\u4ef6\u7cfb\u7edf\u4fe1\u606f struct files_struct *files; // \u6253\u5f00\u7684\u6587\u4ef6 struct signal_struct *signal; struct sighand_struct *sighand; struct sigpending pending; void *stack; // \u6307\u5411\u5185\u6838\u6808\u7684\u6307\u9488 ... } \u800c\u5176\u4e2dmm_struct\u9577\u9019\u6a23 struct mm_struct { struct vm_area_struct * mmap; /* list of VMAs */ struct rb_root mm_rb; unsigned long mmap_base; /* base of mmap area */ unsigned long task_size; /* size of task vm space */ pgd_t * pgd; atomic_t mm_count; /* How many references to \"struct mm_struct\" (users count as 1) */ int map_count; /* number of VMAs */ unsigned long start_code, end_code, start_data, end_data; unsigned long start_brk, brk, start_stack; unsigned long arg_start, arg_end, env_start, env_end; struct file *exe_file; /* ... some code omitted ... */ }; \u5176\u4e2d\u6709\u95dcvirtual address intervals\u7684\u8cc7\u8a0a: unsigned long start_code, end_code, start_data, end_data; unsigned long start_brk, brk, start_stack; unsigned long arg_start, arg_end, env_start, env_end; \u9019\u4e9b\u8b8a\u6578\u5b58\u7684\u662fprocess memory layout\u4e2d\u500b\u5340\u584a\u7684\u8d77\u59cb, \u7d50\u675f\u4f4d\u5740\uff0c\u4f8b\u5982text segments\u5c31\u662fstart_code ~ end_code struct vm_area_struct * mmap; mmap\u7d00\u9304\u9032\u7a0b\u4f7f\u7528\u5230\u7684VMA\u5011 \u5176\u4e2dvm_area_struct\u4e2d\u6bd4\u8f03\u91cd\u8981\u7684\u8cc7\u6599\u6709 unsigned long vm_start\uff1a\u8a18\u9304\u6b64 VMA \u5340\u584a\u7684\u958b\u59cb\u4f4d\u5740 unsigned long vm_end\uff1a\u8a18\u9304\u6b64 VMA \u5340\u584a\u7684\u7d50\u675f\u4f4d\u5740 struct vm_area_struct *vm_next\uff1a\u6307\u5411\u4e0b\u4e00\u500b VMA \u5340\u584a\u7d50\u69cb\u7684\u6307\u6a19 \u6211\u731c\u6240\u6709VMA\u7684\u4f4d\u5740\u5c31\u662fprocess\u7684virtual address intervals\u4e86\u5427! void my_copy(char *result, unsigned long address, size_t length){ if(copy_to_user(result, &address, length)) printk(\"error while copy_to_user\\n\"); } while(mmap->vm_next != NULL){ my_copy(result, mmap->vm_start, length); result += length; my_copy(result, mmap->vm_end, length); result += length; mmap = mmap->vm_next; } my_copy(result, state_end, length); result += length; result += length; \u9019\u908a\u5728\u505a\u7684\u4e8b\u5c31\u662f\u628a\u6bcf\u4e00\u500bvma\u7684vm_start\u548cvm_end\u642c\u5230result\uff0c\u642c\u904e\u53bb\u4e4b\u5f8c\u518d\u5c07result\u5f80\u5f8clength(sizeof(unsigned long))\u500bbytes \u7531\u65bc\u6211\u662f\u6bcf\u500b\u5169\u500baddress\u70ba\u4e00\u7d44\uff0c\u6240\u4ee5\u6700\u5f8cstate_end\u6211\u4e5f\u4fdd\u7559\u5169\u500b\u8b8a\u6578\u7684\u4f4d\u5740","title":"Linux kernel \u4e2d\u9032\u7a0b\u7528 task_struct \u7d50\u69cb\u9ad4\u8868\u793a"},{"location":"linux-kernel/project-1/#2-corresponding-physical-address-intervals","text":"\u7406\u89e3linux paging\u5c31\u5f88\u597d\u627e\u4e86 #include <linux/kernel.h> #include <linux/sched.h> #include <asm/pgtable.h> static unsigned long vaddr2paddr(unsigned long vaddr){ pgd_t *pgd; pud_t *pud; pmd_t *pmd; pte_t *pte; unsigned long paddr=0, page_addr=0, page_offset=0; pgd = pgd_offset(current->mm, vaddr); if (pgd_none(*pgd)) { printk(\"not mapped in pgd\\n\"); return -1; } pud = pud_offset(pgd, vaddr); if (pud_none(*pud)) { printk(\"not mapped in pud\\n\"); return -1; } pmd = pmd_offset(pud, vaddr); if (pmd_none(*pmd)) { printk(\"not mapped in pmd\\n\"); return -1; } pte = pte_offset_kernel(pmd, vaddr); if (pte_none(*pte)) { printk(\"not mapped in pte\\n\"); return -1; } page_addr = pte_val(*pte) & PAGE_MASK; page_offset = vaddr & ~PAGE_MASK; paddr = page_addr | page_offset; return paddr; } \u900f\u904epgd_offset, pud_offset, pmd_offset, pte_offset_kernel\u53d6\u5f97page table\uff0c\u518d\u914d\u5408PAGE_MASK\u53d6\u5f97physical address\uff0c\u5176\u4e2d\u4e26\u4e0d\u662f\u6bcf\u500bvirtual address\u90fd\u6709\u5206\u914d\u5230physical address\uff0c\u6240\u4ee5\u53ef\u80fd\u5728\u53d6\u67d0\u7d1a\u5206\u9801\u6642\u767c\u751f\u53d6\u4e0d\u5230\u7684\u72c0\u6cc1\uff0c\u6b64\u6642\u6211\u5011\u5c31\u53ef\u4ee5\u5224\u65b7\u8a72virtual address\u6c92\u6709\u88ab\u5206\u914d\u5230 mmap = mm->mmap; while(mmap->vm_next != NULL){ for(i=mmap->vm_start ; i<=mmap->vm_end ; i+=(~PAGE_MASK)+1){ unsigned long page_start = i, page_end = i+(~PAGE_MASK); unsigned long frame_start = vaddr2paddr(page_start), frame_end = vaddr2paddr(page_end); if(frame_start){ my_copy(result, page_start, length); result += length; my_copy(result, page_end, length); result += length; my_copy(result, frame_start, length); result += length; my_copy(result, frame_end, length); result += length; } } my_copy(result, vma_end, length); result += length; result += length; result += length; result += length; mmap = mmap->vm_next; } my_copy(result, state_end, length); result += length; result += length; result += length; result += length; \u7531\u65bcvirtual address\u5c0d\u5230physical address\u662f\u4ee5page\u70ba\u55ae\u4f4d\uff0c\u4e5f\u5c31\u662f\u8aaa\u4e00\u584apage\u7684\u8d77\u59cb\u4f4d\u7f6e\u6709\u5c0d\u61c9\u7684physical address\u5247\u4ee3\u8868\u6574\u584apage\u90fd\u6709\uff0c\u6240\u4ee5\u6211\u5c31\u905e\u8ff4\u904e\u6bcf\u500bvma\u4e2d\u7684\u6bcf\u500bpage \u9019\u908a\u6211\u662f\u4ee5\u6bcf\u56db\u500b\u8cc7\u6599\u70ba\u4e00\u7d44(page\u982d\u5c3e+frame\u982d\u5c3e)\uff0c\u96d6\u7136\u9019\u9ebc\u591aresult+=length\u6709\u9ede\u919c\u4e0d\u904e\u6211\u61f6\u5f97\u7528\u5176\u4ed6\u65b9\u6cd5\u4e86","title":"2. \u518d\u4f86\u6211\u5011\u8981\u53d6\u5f97corresponding physical address intervals"},{"location":"linux-kernel/project-1/#3-system-callvirtual-addressphysical-address","text":"\u6211\u9019\u908a\u6e2c\u8a66\u7aef\u6309\u7167\u525b\u525b\u7684\u5132\u5b58\u65b9\u5f0f\u6293\u51fa 1 . virtual address intervals \u9019\u6642\u53ef\u4ee5\u9806\u4fbf\u8a08\u7b97virtual address\u7e3d\u6578 int virtual_cnt = 0, physical_cnt = 0; const int length = sizeof(unsigned long); for(int i=0 ; ; i++) { unsigned long vm_start, vm_end; memcpy(&vm_start, result, length); next memcpy(&vm_end, result, length); next if(vm_start == STATE_END) break; virtual_cnt += (vm_end - vm_start); fprintf(pfile, \"vma%d: 0x%lx ~ 0x%lx\\n\", i+1, vm_start, vm_end); } 2 . physical address intervals \u9806\u4fbf\u7b97\u51faphysical address\u7e3d\u6578 fprintf(pfile, \"physical address intervals: \\n\"); for(int i=0 ; ; ){ unsigned long page_start, page_end, frame_start, frame_end; memcpy(&page_start, result, length); next memcpy(&page_end, result, length); next memcpy(&frame_start, result, length); next memcpy(&frame_end, result, length); next if(page_start == STATE_END) break; if(page_start == VMA_END){ // fprintf(pfile, \"\\n\"); continue; } physical_cnt += MASK; i++; fprintf(pfile, \"0x%lx ~ 0x%lx -> 0x%lx ~ 0x%lx\\n\", page_start, page_end, frame_start, frame_end); } \u5176\u4e2d\u6211\u9019\u908a\u628aresult+=length\u66ff\u63db\u6210next\uff0c\u9084\u662f\u6c92\u591a\u597d\u770bqq 3 . \u5370\u51fa printf(\"%s virtual addresses that have physical memory: %.2f% \\n\", filename, (double)physical_cnt/virtual_cnt*100);","title":"3. \u5217\u51fa\u547c\u53ebsystem call\u6642\u6709\u591a\u5c11virtual address\u6709\u5c0d\u61c9\u7684physical address\uff08\u5e7e\u8db4\uff09"},{"location":"linux-kernel/project-1/#4-virtual-address-intervalsphysical-address-intervals","text":"\u9019\u88e1\u5c31\u6709\u9ede\u9ebb\u7169\u4e86\uff0c\u7531\u65bcfork()\u5f8c\u8b8a\u6210\u5169\u500bprocess\u4e0d\u80fd\u76f4\u63a5\u628a\u8cc7\u6599\u5b58\u5230\u8b8a\u6578\u4e2d(child\u5b58\u7684parent\u770b\u4e0d\u5230)\uff0c\u6240\u4ee5\u5fc5\u9808\u8981\u518d\u8b80\u6a94\u6848\u4f86\u5206\u6790\uff0c\u8d85\u9ebb\u7169\u554a\u554a\u554a\u554a\u554a\u554a\u554a \u5148\u5ba3\u544a\u4e00\u500bstruct\u4f86\u5b58\u6211\u5011\u8981\u7684\u8cc7\u6599 struct page{ unsigned long page_start; unsigned long frame_start; }; \u8b80\u6a94\u5f8c\u5b58\u5728\u9663\u5217\u4e2d void analyze_file(char *filename, struct page *pages){ FILE *pfile; pfile = fopen(filename, \"r\"); if(!pfile){ printf(\"open file error!\\n\"); return; } // \u5148\u6293\u6389\u524d\u9762\u7684vma list char useless[100]; while(fscanf(pfile, \"%[^\\n]\", useless) != EOF && strcmp(useless, \"physical address intervals: \")) fscanf(pfile, \"\\n\", useless); fscanf(pfile, \"%[^\\n]\", useless); fscanf(pfile, \"\\n\", useless); // \u6211\u5011\u8981\u7684\u8cc7\u8a0a unsigned long page_start, page_end, frame_start, frame_end; int i=0; while(fscanf(pfile, \"0x%lx ~ 0x%lx -> 0x%lx ~ 0x%lx\\n\", &page_start, &page_end, &frame_start, &frame_end) != EOF){ pages[i].page_start = page_start; pages[i].frame_start = frame_start; i++; } fclose(pfile); } \u6700\u5f8c\u518d\u5206\u5225\u62ff\u5169\u500bchild\u7684result\u505a\u6bd4\u5c0d\uff08\u6211\u5c31\u76f4\u63a5\u66b4\u641c\u4e86\uff09 void calc_phy_relation(struct page *child, struct page *parent, int num){ printf(\"\\n\\nthe virtual address intervals that map to same physical address at result_%d\\n\", num); for(int i=0 ; i<300 ; i++){ if(!child[i].page_start && !child[i].frame_start) break; for(int j=0 ; j<300 ; j++){ if(!parent[j].page_start && !parent[j].frame_start) break; if(child[i].frame_start == parent[j].frame_start){ printf(\"0x%lx ~ 0x%lx\\n\", child[i].page_start, child[i].page_start+MASK-1); break; } } } } \u5b8c\u6210\u62c9\uff5e\uff5e\u5176\u5be6\u9ebb\u7169\u7684\u90fd\u5728\u8cc7\u6599\u8655\u7406 reference: http://gityuan.com/2017/07/30/linux-process/ https://www.cnblogs.com/kwingmei/p/3731746.html https://www.cnblogs.com/Rofael/archive/2013/04/13/3019153.html https://www.ffutop.com/posts/2019-07-17-understand-kernel-13/ https://stackoverflow.com/questions/5748492/is-there-any-api-for-determining-the-physical-address-from-virtual-address-in-li http://www.jollen.org/blog/2007/01/process_vma.html","title":"4. \u5370\u51fa\u54ea\u4e9bvirtual address intervals\u5c0d\u61c9\u5230\u76f8\u540c\u7684physical address intervals"},{"location":"modern-cpp/prepare/","text":"\u7531\u65bc\u5beb\u4e86C++ \u90a3\u9ebc\u591a\u5e74\u96d6\u7136\u77e5\u9053\u6709C11, C14\u7b49\u6a19\u6e96\u6162\u6162\u88ab\u767c\u5c55\u51fa\u4f86\uff0c\u4f46\u662f\u59cb\u7d42\u6c92\u6709\u597d\u597d\u4e86\u89e3 C++ \u548c C \u4e0a\u7684\u5dee\u7570\uff0c\u6642\u5e38\u767c\u73fe\u7528C++ \u5beb\u51fa\u4f86\u7684 code \u548c C \u5dee\u4e0d\u591a\uff0c\u6240\u4ee5\u6253\u7b97\u82b1\u6bb5\u6642\u9593\u4f86\u7814\u7a76\u7814\u7a76\uff0c\u63a5\u4e0b\u4f86\u5e7e\u7bc7\u662f\u6211\u770b Modern C++ Tutorial: C++11/14/17/20 On the Fly \u7684\u7b46\u8a18 \u4f5c\u8005\u63d0\u5230\u5e0c\u671b\u6211\u5011\u4e0d\u8981\u6709 \"C++ is not a superset of C\" \u7684\u60f3\u6cd5\uff0c\u76e1\u91cf\u5728C++ \u4e2d\u907f\u514d C style \u7684\u5beb\u6cd5\uff0c\u7576\u4f60\u9700\u8981\u4f7f\u7528\u5230 C \u6642\u8981\u5c07 C code \u548c C++ code \u5206\u958b\uff0c\u4e26\u7528\u4e0d\u540c\u7684\u65b9\u5f0f\u7de8\u8b6f\u518d include Deprecated Features \u4e0d\u8a72\u5c07 string literal constant \u7d66 char* \u61c9\u8a72\u7528 auto \u6216 const char* \u4ee3\u66ff char *str = \"literal constant\" // warning noexcept \u53d6\u4ee3 unexpected_handler , set_unexpected() \u7b49 unique_ptr \u53d6\u4ee3 auto_ptr register \u53ef\u4ee5\u4f7f\u7528\u4f46\u4e0d\u518d\u6709\u4efb\u4f55\u5be6\u969b\u610f\u7fa9 \u4e0d\u80fd\u5c0d bool \u8b8a\u6578\u4f7f\u7528 ++ explicitly declaring a destructor will prevent the implicit generation of a move constructor and move assignment operator. \u81f3\u65bc\u70ba\u4ec0\u9ebc\u8981\u9019\u500b\u641e\u6211\u5011\u5f8c\u7e8c\u518d\u8a0e\u8ad6 \u4f7f\u7528 static_cast , reinterpret_cast , const_cast \u53d6\u4ee3C\u8a9e\u8a00\u98a8\u683c\u7684\u578b\u614b\u8f49\u63db ( \u5728\u8b8a\u6578\u524d\u9762\u52a0(type) ) C++17 \u4e2d\u68c4\u7528\u4e86\u4e00\u4e9b C \u51fd\u5f0f\u5eab\uff0c\u50cf\u662f <cstdbool> , <ctgmath> \u7b49 \u9084\u6709\u5f88\u591a\u5f88\u591a ... \u7576\u7136\u4f60\u9084\u662f\u53ef\u4ee5\u4f7f\u7528\u4e0a\u8ff0\u9019\u4e9b\u7279\u6027\uff0cDeprecated \u53ea\u662f\u8981\u544a\u8a34\u4f60\u9019\u4e9b\u7279\u6027\u5728\u672a\u4f86\u53ef\u80fd\u6703\u4e0d\u5728\u662f\u6a19\u6e96\uff0c\u958b\u767c\u8005\u6700\u597d\u5148\u5617\u8a66\u9069\u61c9\u6216\u6539\u8b8a\u7fd2\u6163 >< Deprecation is not completely unusable, it is only intended to imply that programmers will disappear from future standards and should be avoided. However, the deprecated features are still part of the standard library, and most of the features are actually \"permanently\" reserved for compatibility reasons. \u7de8\u8b6f $ clang++ -std=c++2a","title":"\u6e96\u5099"},{"location":"modern-cpp/prepare/#deprecated-features","text":"\u4e0d\u8a72\u5c07 string literal constant \u7d66 char* \u61c9\u8a72\u7528 auto \u6216 const char* \u4ee3\u66ff char *str = \"literal constant\" // warning noexcept \u53d6\u4ee3 unexpected_handler , set_unexpected() \u7b49 unique_ptr \u53d6\u4ee3 auto_ptr register \u53ef\u4ee5\u4f7f\u7528\u4f46\u4e0d\u518d\u6709\u4efb\u4f55\u5be6\u969b\u610f\u7fa9 \u4e0d\u80fd\u5c0d bool \u8b8a\u6578\u4f7f\u7528 ++ explicitly declaring a destructor will prevent the implicit generation of a move constructor and move assignment operator. \u81f3\u65bc\u70ba\u4ec0\u9ebc\u8981\u9019\u500b\u641e\u6211\u5011\u5f8c\u7e8c\u518d\u8a0e\u8ad6 \u4f7f\u7528 static_cast , reinterpret_cast , const_cast \u53d6\u4ee3C\u8a9e\u8a00\u98a8\u683c\u7684\u578b\u614b\u8f49\u63db ( \u5728\u8b8a\u6578\u524d\u9762\u52a0(type) ) C++17 \u4e2d\u68c4\u7528\u4e86\u4e00\u4e9b C \u51fd\u5f0f\u5eab\uff0c\u50cf\u662f <cstdbool> , <ctgmath> \u7b49 \u9084\u6709\u5f88\u591a\u5f88\u591a ... \u7576\u7136\u4f60\u9084\u662f\u53ef\u4ee5\u4f7f\u7528\u4e0a\u8ff0\u9019\u4e9b\u7279\u6027\uff0cDeprecated \u53ea\u662f\u8981\u544a\u8a34\u4f60\u9019\u4e9b\u7279\u6027\u5728\u672a\u4f86\u53ef\u80fd\u6703\u4e0d\u5728\u662f\u6a19\u6e96\uff0c\u958b\u767c\u8005\u6700\u597d\u5148\u5617\u8a66\u9069\u61c9\u6216\u6539\u8b8a\u7fd2\u6163 >< Deprecation is not completely unusable, it is only intended to imply that programmers will disappear from future standards and should be avoided. However, the deprecated features are still part of the standard library, and most of the features are actually \"permanently\" reserved for compatibility reasons.","title":"Deprecated Features"},{"location":"modern-cpp/prepare/#_1","text":"$ clang++ -std=c++2a","title":"\u7de8\u8b6f"},{"location":"modern-cpp/usability/","text":"Constant nullptr \u50b3\u7d71 C++ \u628a NULL \u7576\u6210 0 \u6216\u662f (void*)0 \uff0c\u9019\u53ef\u80fd\u6703\u767c\u751f\u5e7e\u500b\u554f\u984c NULL = (void*)0 : C++ \u4e0d\u5141\u8a31\u5c07 (void*) \u8f49\u63db\u70ba\u5176\u4ed6\u578b\u614b\uff0c\u6240\u4ee5\u4ee5\u4e0b\u7684\u7a0b\u5f0f\u6703\u6709\u554f\u984c char *str = NULL; NULL = 0 : \u96d6\u7136\u8aaa\u5c07 NULL \u5b9a\u7fa9\u6210 0 \u53ef\u4ee5\u89e3\u6c7a\u4e0a\u8ff0\u554f\u984c\uff0c\u4f46\u662f\u4f7f\u7528 overloading \u6642 void foo(char*); void foo(int); foo(NULL) \u6703\u9078\u64c7 void foo(int) \uff0c\u56e0\u70ba\u901a\u5e38\u6211\u5011\u4f7f\u7528 NULL \u90fd\u662f\u8981\u50b3\u7d66\u6307\u6a19\uff0c\u7d50\u679c\u537b\u662f\u547c\u53eb\u53c3\u6578 int \uff0c\u5341\u5206\u4e0d\u76f4\u89c0 \u70ba\u4e86\u89e3\u6c7a\u9019\u4e9b\u554f\u984c\uff0cC++11 \u5370\u5165\u4e86 nullptr \uff0c\u5176\u578b\u614b\u70ba nullptr_t \uff0c\u53ef\u4ee5\u8f49\u63db\u6210\u4efb\u4f55\u578b\u614b\u7684\u6307\u6a19 foo(0); // call foo(int) foo(NULL); // error foo(nullptr); // call foo(char*) constexpr \u5728 C++ \u4e2d\u5ba3\u544a\u9663\u5217\u6642\u53ea\u80fd\u4f7f\u7528 constant expression \u4f86\u6307\u5b9a\u9663\u5217\u5927\u5c0f\uff0c\u5373\u4f7f\u662f const \u8b8a\u6578\u4e5f\u662f\u975e\u6cd5\u7684 int len = 10; int arr[len]; //illegal const in len2 = 10; int arr2[len2]; //illegal \u4e0d\u904e\u5927\u5bb6\u4e00\u5b9a\u90fd\u7528\u904e\u4e0a\u8ff0\u7b2c\u4e8c\u7a2e\u65b9\u6cd5\u4f86\u6307\u5b9a\u9663\u5217\u5927\u5c0f\uff0c\u800c\u4e14 compiler \u4e5f\u90fd\u6c92\u6709\u5674\u904e\u932f\uff0c\u90a3\u662f\u56e0\u70ba\u5927\u591a\u6578 compiler \u90fd\u6709\u512a\u5316\uff0c\u4f7f\u5f97\u4e00\u4e9b\u4e0d\u5408\u6cd5\u7684\u5beb\u6cd5\u4e5f\u53ef\u4ee5\u88ab\u63a5\u53d7 \u5728 C++ 11 \u4e4b\u524d\u7de8\u8b6f\u5668\u7121\u6cd5\u660e\u78ba\u77e5\u9053\u8a72\u8b8a\u6578\u6216\u662f\u51fd\u6578\u56de\u50b3\u503c\u5c31\u662f\u500b\u5e38\u91cf\uff0c\u6240\u4ee5\u5728 C++11 \u4e2d\u5f15\u5165 constexpr \u9019\u500b\u95dc\u9375\u5b57\u544a\u8a34\u7de8\u8b6f\u5668\u61c9\u8a72\u53bb\u9a57\u8b49\u8a72\u8b8a\u6578\u6216\u662f\u51fd\u6578\u56de\u50b3\u503c\u5728\u7de8\u8b6f\u671f\u5c31\u662f\u4e00\u500b constant expression\uff0c\u4ee5\u4e0b\u90fd\u662f\u5408\u6cd5\u7684 constexpr int len_foo_constexpr() { return 5; } ... constexpr int len = 10; int arr[len]; constexpr int len2 = 1 + 2 + 3; int arr2[len2]; int arr3[len_foo_constexpr()]; ... constexpr \u7684\u51fd\u6578\u4e5f\u53ef\u4ee5\u7528\u65bc\u905e\u8ff4 constexpr int fibonacci(const int n) { return n == 1 || n == 2 ? 1 : fibonacci(n-1) + fibonacci(n-2); } Variables and initialization declare variable in if/switch \u5728 C++17 \u4e4b\u524d\u5982\u679c\u6211\u5011\u8981\u627e\u5230 vector \u4e2d\u7684\u7279\u5b9a\u503c\u4e26\u4fee\u6539\u4ed6 const std::vector<int>::iterator itr = std::find(vec.begin(), vec.end(), 2); if (itr != vec.end()) *itr = 3; \u9019\u500b\u5730\u65b9\u7684 itr \u53ea\u662f\u500b\u66ab\u6642\u8a18\u9304\u7528\u7684\u8b8a\u6578\uff0c\u8ddf\u4f60\u5beb for \u6642\u88e1\u9762\u6703\u7528\u5230\u7684 i \u4e00\u6a23\uff0c\u7576\u4f60\u5df2\u7d93\u50cf\u4e0a\u8ff0\u5ba3\u544a\u904e itr \uff0c for \u8ff4\u5708\u7684\u8b8a\u6578\u540d\u7a31\u5c31\u53ea\u80fd\u63db\u4e00\u500b\u7528\uff0c\u5728 C++17 \u5f8c\u6211\u5011\u53ef\u4ee5\u5728 if \u4e2d\u5ba3\u544a\u8b8a\u6578\uff0c\u8b93\u958b\u767c\u8005\u53ef\u4ee5\u514d\u53bb\u9019\u7a2e\u5c0f\u7169\u60f1 if (const std::vector<int>::iterator itr = std::find(vec.begin(), vec.end(), 3); itr != vec.end()) *itr = 4; initializer_list C++ 11 \u5f15\u5165\u65b0\u7684\u578b\u614b <initializer_list> \uff0c\u9019\u500b\u578b\u614b\u7c21\u5316\u4e86 C++ STL \u7684\u521d\u59cb\u5316\uff0c\u4ee5\u5f80\u6211\u5011\u91dd\u5c0d\u4e0d\u540c\u7684 STL \u5bb9\u5668\u7684\u521d\u59cb\u5316\u65b9\u5f0f\u90fd\u4e0d\u540c # vector 1 int arr[] = {1, 2, 3, 4, 5}; vector<int> vec(arr, arr+sizeof(arr)); # vector 2 vector<int> arr2; for(int i=1 ; i<=5 ; i++) arr2.emplace_back(i); # emplace \u5f8c\u9762\u6703\u63d0\u5230 # map map<string, string> mp; mp[\"one\"] = \"Taipei\"; mp[\"two\"] = \"Taoyuan\"; \u53ef\u4ee5\u770b\u5230\u8981\u561b\u8981\u5148\u5efa\u4e00\u500b\u9663\u5217\u8981\u561b\u4e00\u500b\u4e00\u500b\u653e\uff0c\u904b\u7528 <initializer_list> \u7684\u7279\u6027\u5c31\u7c21\u5316\u8a31\u591a vector<int> vec = {1, 2, 3, 4, 5}; map<string, string> mp = { \"one\": \"Taipei\", \"two\": \"Taoyuan\", ... } \u9664\u4e86\u521d\u59cb\u5316 container \u5916\u4e5f\u53ef\u4ee5\u7528\u4f86\u521d\u59cb\u5316\u6211\u5011\u81ea\u5df1\u5beb\u7684 class \uff0c\u6211\u5011\u53ea\u9700\u8981\u5728 class \u4e2d\u5b9a\u7fa9\u4e00\u500b\u3000 initialize list constructor class MagicFoo { public: std::vector<int> vec; MagicFoo(std::initializer_list<int> list) { for (std::initializer_list<int>::iterator it = list.begin(); it != list.end(); ++it) vec.push_back(*it); } }; ... MagicFoo = {1, 2, 3, 4, 5}; \u57fa\u672c\u4e0a\u53ea\u8981\u7528\u5230\u5927\u62ec\u865f\u8af8\u5982\u521d\u59cb\u5316\u3001\u51fd\u5f0f\u53c3\u6578\uff0c\u5c31\u6703\u81ea\u52d5\u5efa\u69cb\u4e00\u500b initialize list \uff0c\u53ef\u4ee5\u628a\u5b83\u770b\u6210\u4e00\u500b\u5e38\u91cf\uff0c\u7576\u4f60\u8907\u88fd initialize list \u4e26\u4e0d\u6703\u771f\u7684\u8907\u88fd\u800c\u662f\u5f15\u7528\u800c\u5df2\u3002 Structured binding C++ 11 \u5f8c\u5f15\u5165 <tuple> \u8b93\u6211\u5011\u53ef\u4ee5\u628a\u4e0d\u540c\u503c\u5305\u5728\u4e00\u8d77\uff0c\u4f46\u662f\u5728 C++17 \u5f8c\u624d\u80fd\u65b9\u4fbf\u7684\u4f7f\u7528\uff0c\u5982\u4e0b tuple<int, double, string> foo() { return make_tuple(1, 1.1, \"111\"); } ... auto [x, y, z] = foo(); Type inference C++ \u8ddf C \u7684\u5de8\u5927\u5340\u5225\u4e4b\u4e00\u5c31\u662f\u5f15\u5165\u4e86 auto \u548c decltype \uff0c auto \u5927\u5bb6\u90fd\u5f88\u719f\u5c31\u4e0d\u591a\u8aaa\u4e86\uff0c\u53ea\u662f\u6709\u5169\u9ede\u8981\u6ce8\u610f \u4e0d\u80fd\u7528\u4f86\u7576\u4f5c\u51fd\u5f0f\u53c3\u6578\u7684\u578b\u614b int add(auto x, auto y); // error \u4e0d\u80fd\u7528\u65bc\u5ba3\u544a\u9663\u5217 auto arr[10]; // error \u6703\u6709\u4ee5\u4e0a\u5169\u7a2e\u9650\u5236\u4e5f\u662f\u5f88\u81ea\u7136\u7684\uff0c\u4e0a\u8ff0\u72c0\u6cc1\u90fd\u6709\u95dc\u8a18\u61b6\u9ad4\u5206\u914d\uff0c\u5982\u679c\u6307\u5b9a\u70ba auto \u7a0b\u5f0f\u6703\u4e0d\u77e5\u9053\u8a72\u5206\u914d\u591a\u5c11\u5927\u5c0f\u7684\u4f4d\u5740\u3002 decltype decltype \u7528\u4f86\u8a08\u7b97\u67d0\u8868\u9054\u5f0f\u7684\u985e\u578b -> decltype(expression) auto x = 1; auto y = 2; decltype(x+y) z; \u6216\u662f\u642d\u914d is_same<T, U>::value \u5224\u65b7\u5169\u500b\u985e\u578b\u662f\u5426\u76f8\u7b49 if (is_same<decltype(x), int>::value) cout << \"type x == int\" << endl; \u53e6\u5916\u5728 C++ \u4e2d\u662f\u4e0d\u80fd\u628a\u985e\u578b\u7576\u4f5c\u53c3\u6578\u7684\uff0c\u6240\u4ee5\u5982\u679c\u4f60\u5617\u8a66\u5370\u51fa\u985e\u578b\u6703\u5674\u932f cout << decltype(x) << endl; // error \u6240\u4ee5\u5982\u679c\u4f60\u771f\u7684\u60f3\u8981\u5370\u51fa\u67d0\u500b\u8b8a\u6578\u7684\u985e\u578b\u53ef\u4ee5\u900f\u904e template template <class T> void printType(const T&){ cout << __PRETTY_FUNCTION__ << endl; } ... printType(x); // output $ void printType(const T&) [with T = int] tail type inference \u524d\u9762\u63d0\u5230\u8aaa auto \u4e0d\u80fd\u7576\u4f5c\u51fd\u5f0f\u53c3\u6578\u7684\u985e\u578b\uff0c\u90a3\u80fd\u4e0d\u80fd\u7576\u4f5c\u8fd4\u56de\u578b\u614b\u5462\uff0cC++ 14 \u5f8c\u53ef\u4ee5 template<typename T, typename U> auto add(T x, U y){ return x + y; } tail type inference \u662f\u5728 C++14 \u4e4b\u524d\u56e0\u70ba\u51fd\u6578\u4e0d\u5177\u5099\u8fd4\u56de\u503c\u63a8\u5c0e\uff0c\u6240\u4ee5\u9700\u8981\u9019\u500b\u6a5f\u5236\u4f86\u6307\u5b9a\u8fd4\u56de\u578b\u614b template<typename T, typename U> auto add(T x, U y) -> decltype(\uff58+y){ return x + y; } \u81f3\u65bc\u70ba\u4ec0\u9ebc\u4e0d\u628a\u8fd4\u56de\u578b\u614b\u5beb\u6210 decltype(\uff58+y) \u5c31\u597d\u662f\u56e0\u70ba\u8b80\u5230\u524d\u9762\u662f\u7a0b\u5f0f\u9084\u4e0d\u77e5\u9053 x \u548c y \u662f\u4ec0\u9ebc decltype(auto) ?? \u4f5c\u8005\u8868\u793a\u8981\u770b\u5b8c\u4e0b\u4e00\u7ae0\u6bd4\u8f03\u597d\u7406\u89e3","title":"Usability"},{"location":"modern-cpp/usability/#constant","text":"","title":"Constant"},{"location":"modern-cpp/usability/#nullptr","text":"\u50b3\u7d71 C++ \u628a NULL \u7576\u6210 0 \u6216\u662f (void*)0 \uff0c\u9019\u53ef\u80fd\u6703\u767c\u751f\u5e7e\u500b\u554f\u984c NULL = (void*)0 : C++ \u4e0d\u5141\u8a31\u5c07 (void*) \u8f49\u63db\u70ba\u5176\u4ed6\u578b\u614b\uff0c\u6240\u4ee5\u4ee5\u4e0b\u7684\u7a0b\u5f0f\u6703\u6709\u554f\u984c char *str = NULL; NULL = 0 : \u96d6\u7136\u8aaa\u5c07 NULL \u5b9a\u7fa9\u6210 0 \u53ef\u4ee5\u89e3\u6c7a\u4e0a\u8ff0\u554f\u984c\uff0c\u4f46\u662f\u4f7f\u7528 overloading \u6642 void foo(char*); void foo(int); foo(NULL) \u6703\u9078\u64c7 void foo(int) \uff0c\u56e0\u70ba\u901a\u5e38\u6211\u5011\u4f7f\u7528 NULL \u90fd\u662f\u8981\u50b3\u7d66\u6307\u6a19\uff0c\u7d50\u679c\u537b\u662f\u547c\u53eb\u53c3\u6578 int \uff0c\u5341\u5206\u4e0d\u76f4\u89c0 \u70ba\u4e86\u89e3\u6c7a\u9019\u4e9b\u554f\u984c\uff0cC++11 \u5370\u5165\u4e86 nullptr \uff0c\u5176\u578b\u614b\u70ba nullptr_t \uff0c\u53ef\u4ee5\u8f49\u63db\u6210\u4efb\u4f55\u578b\u614b\u7684\u6307\u6a19 foo(0); // call foo(int) foo(NULL); // error foo(nullptr); // call foo(char*)","title":"nullptr"},{"location":"modern-cpp/usability/#constexpr","text":"\u5728 C++ \u4e2d\u5ba3\u544a\u9663\u5217\u6642\u53ea\u80fd\u4f7f\u7528 constant expression \u4f86\u6307\u5b9a\u9663\u5217\u5927\u5c0f\uff0c\u5373\u4f7f\u662f const \u8b8a\u6578\u4e5f\u662f\u975e\u6cd5\u7684 int len = 10; int arr[len]; //illegal const in len2 = 10; int arr2[len2]; //illegal \u4e0d\u904e\u5927\u5bb6\u4e00\u5b9a\u90fd\u7528\u904e\u4e0a\u8ff0\u7b2c\u4e8c\u7a2e\u65b9\u6cd5\u4f86\u6307\u5b9a\u9663\u5217\u5927\u5c0f\uff0c\u800c\u4e14 compiler \u4e5f\u90fd\u6c92\u6709\u5674\u904e\u932f\uff0c\u90a3\u662f\u56e0\u70ba\u5927\u591a\u6578 compiler \u90fd\u6709\u512a\u5316\uff0c\u4f7f\u5f97\u4e00\u4e9b\u4e0d\u5408\u6cd5\u7684\u5beb\u6cd5\u4e5f\u53ef\u4ee5\u88ab\u63a5\u53d7 \u5728 C++ 11 \u4e4b\u524d\u7de8\u8b6f\u5668\u7121\u6cd5\u660e\u78ba\u77e5\u9053\u8a72\u8b8a\u6578\u6216\u662f\u51fd\u6578\u56de\u50b3\u503c\u5c31\u662f\u500b\u5e38\u91cf\uff0c\u6240\u4ee5\u5728 C++11 \u4e2d\u5f15\u5165 constexpr \u9019\u500b\u95dc\u9375\u5b57\u544a\u8a34\u7de8\u8b6f\u5668\u61c9\u8a72\u53bb\u9a57\u8b49\u8a72\u8b8a\u6578\u6216\u662f\u51fd\u6578\u56de\u50b3\u503c\u5728\u7de8\u8b6f\u671f\u5c31\u662f\u4e00\u500b constant expression\uff0c\u4ee5\u4e0b\u90fd\u662f\u5408\u6cd5\u7684 constexpr int len_foo_constexpr() { return 5; } ... constexpr int len = 10; int arr[len]; constexpr int len2 = 1 + 2 + 3; int arr2[len2]; int arr3[len_foo_constexpr()]; ... constexpr \u7684\u51fd\u6578\u4e5f\u53ef\u4ee5\u7528\u65bc\u905e\u8ff4 constexpr int fibonacci(const int n) { return n == 1 || n == 2 ? 1 : fibonacci(n-1) + fibonacci(n-2); }","title":"constexpr"},{"location":"modern-cpp/usability/#variables-and-initialization","text":"","title":"Variables and initialization"},{"location":"modern-cpp/usability/#declare-variable-in-ifswitch","text":"\u5728 C++17 \u4e4b\u524d\u5982\u679c\u6211\u5011\u8981\u627e\u5230 vector \u4e2d\u7684\u7279\u5b9a\u503c\u4e26\u4fee\u6539\u4ed6 const std::vector<int>::iterator itr = std::find(vec.begin(), vec.end(), 2); if (itr != vec.end()) *itr = 3; \u9019\u500b\u5730\u65b9\u7684 itr \u53ea\u662f\u500b\u66ab\u6642\u8a18\u9304\u7528\u7684\u8b8a\u6578\uff0c\u8ddf\u4f60\u5beb for \u6642\u88e1\u9762\u6703\u7528\u5230\u7684 i \u4e00\u6a23\uff0c\u7576\u4f60\u5df2\u7d93\u50cf\u4e0a\u8ff0\u5ba3\u544a\u904e itr \uff0c for \u8ff4\u5708\u7684\u8b8a\u6578\u540d\u7a31\u5c31\u53ea\u80fd\u63db\u4e00\u500b\u7528\uff0c\u5728 C++17 \u5f8c\u6211\u5011\u53ef\u4ee5\u5728 if \u4e2d\u5ba3\u544a\u8b8a\u6578\uff0c\u8b93\u958b\u767c\u8005\u53ef\u4ee5\u514d\u53bb\u9019\u7a2e\u5c0f\u7169\u60f1 if (const std::vector<int>::iterator itr = std::find(vec.begin(), vec.end(), 3); itr != vec.end()) *itr = 4;","title":"declare variable in if/switch"},{"location":"modern-cpp/usability/#initializer_list","text":"C++ 11 \u5f15\u5165\u65b0\u7684\u578b\u614b <initializer_list> \uff0c\u9019\u500b\u578b\u614b\u7c21\u5316\u4e86 C++ STL \u7684\u521d\u59cb\u5316\uff0c\u4ee5\u5f80\u6211\u5011\u91dd\u5c0d\u4e0d\u540c\u7684 STL \u5bb9\u5668\u7684\u521d\u59cb\u5316\u65b9\u5f0f\u90fd\u4e0d\u540c # vector 1 int arr[] = {1, 2, 3, 4, 5}; vector<int> vec(arr, arr+sizeof(arr)); # vector 2 vector<int> arr2; for(int i=1 ; i<=5 ; i++) arr2.emplace_back(i); # emplace \u5f8c\u9762\u6703\u63d0\u5230 # map map<string, string> mp; mp[\"one\"] = \"Taipei\"; mp[\"two\"] = \"Taoyuan\"; \u53ef\u4ee5\u770b\u5230\u8981\u561b\u8981\u5148\u5efa\u4e00\u500b\u9663\u5217\u8981\u561b\u4e00\u500b\u4e00\u500b\u653e\uff0c\u904b\u7528 <initializer_list> \u7684\u7279\u6027\u5c31\u7c21\u5316\u8a31\u591a vector<int> vec = {1, 2, 3, 4, 5}; map<string, string> mp = { \"one\": \"Taipei\", \"two\": \"Taoyuan\", ... } \u9664\u4e86\u521d\u59cb\u5316 container \u5916\u4e5f\u53ef\u4ee5\u7528\u4f86\u521d\u59cb\u5316\u6211\u5011\u81ea\u5df1\u5beb\u7684 class \uff0c\u6211\u5011\u53ea\u9700\u8981\u5728 class \u4e2d\u5b9a\u7fa9\u4e00\u500b\u3000 initialize list constructor class MagicFoo { public: std::vector<int> vec; MagicFoo(std::initializer_list<int> list) { for (std::initializer_list<int>::iterator it = list.begin(); it != list.end(); ++it) vec.push_back(*it); } }; ... MagicFoo = {1, 2, 3, 4, 5}; \u57fa\u672c\u4e0a\u53ea\u8981\u7528\u5230\u5927\u62ec\u865f\u8af8\u5982\u521d\u59cb\u5316\u3001\u51fd\u5f0f\u53c3\u6578\uff0c\u5c31\u6703\u81ea\u52d5\u5efa\u69cb\u4e00\u500b initialize list \uff0c\u53ef\u4ee5\u628a\u5b83\u770b\u6210\u4e00\u500b\u5e38\u91cf\uff0c\u7576\u4f60\u8907\u88fd initialize list \u4e26\u4e0d\u6703\u771f\u7684\u8907\u88fd\u800c\u662f\u5f15\u7528\u800c\u5df2\u3002","title":"initializer_list"},{"location":"modern-cpp/usability/#structured-binding","text":"C++ 11 \u5f8c\u5f15\u5165 <tuple> \u8b93\u6211\u5011\u53ef\u4ee5\u628a\u4e0d\u540c\u503c\u5305\u5728\u4e00\u8d77\uff0c\u4f46\u662f\u5728 C++17 \u5f8c\u624d\u80fd\u65b9\u4fbf\u7684\u4f7f\u7528\uff0c\u5982\u4e0b tuple<int, double, string> foo() { return make_tuple(1, 1.1, \"111\"); } ... auto [x, y, z] = foo();","title":"Structured binding"},{"location":"modern-cpp/usability/#type-inference","text":"C++ \u8ddf C \u7684\u5de8\u5927\u5340\u5225\u4e4b\u4e00\u5c31\u662f\u5f15\u5165\u4e86 auto \u548c decltype \uff0c auto \u5927\u5bb6\u90fd\u5f88\u719f\u5c31\u4e0d\u591a\u8aaa\u4e86\uff0c\u53ea\u662f\u6709\u5169\u9ede\u8981\u6ce8\u610f \u4e0d\u80fd\u7528\u4f86\u7576\u4f5c\u51fd\u5f0f\u53c3\u6578\u7684\u578b\u614b int add(auto x, auto y); // error \u4e0d\u80fd\u7528\u65bc\u5ba3\u544a\u9663\u5217 auto arr[10]; // error \u6703\u6709\u4ee5\u4e0a\u5169\u7a2e\u9650\u5236\u4e5f\u662f\u5f88\u81ea\u7136\u7684\uff0c\u4e0a\u8ff0\u72c0\u6cc1\u90fd\u6709\u95dc\u8a18\u61b6\u9ad4\u5206\u914d\uff0c\u5982\u679c\u6307\u5b9a\u70ba auto \u7a0b\u5f0f\u6703\u4e0d\u77e5\u9053\u8a72\u5206\u914d\u591a\u5c11\u5927\u5c0f\u7684\u4f4d\u5740\u3002","title":"Type inference"},{"location":"modern-cpp/usability/#decltype","text":"decltype \u7528\u4f86\u8a08\u7b97\u67d0\u8868\u9054\u5f0f\u7684\u985e\u578b -> decltype(expression) auto x = 1; auto y = 2; decltype(x+y) z; \u6216\u662f\u642d\u914d is_same<T, U>::value \u5224\u65b7\u5169\u500b\u985e\u578b\u662f\u5426\u76f8\u7b49 if (is_same<decltype(x), int>::value) cout << \"type x == int\" << endl; \u53e6\u5916\u5728 C++ \u4e2d\u662f\u4e0d\u80fd\u628a\u985e\u578b\u7576\u4f5c\u53c3\u6578\u7684\uff0c\u6240\u4ee5\u5982\u679c\u4f60\u5617\u8a66\u5370\u51fa\u985e\u578b\u6703\u5674\u932f cout << decltype(x) << endl; // error \u6240\u4ee5\u5982\u679c\u4f60\u771f\u7684\u60f3\u8981\u5370\u51fa\u67d0\u500b\u8b8a\u6578\u7684\u985e\u578b\u53ef\u4ee5\u900f\u904e template template <class T> void printType(const T&){ cout << __PRETTY_FUNCTION__ << endl; } ... printType(x); // output $ void printType(const T&) [with T = int]","title":"decltype"},{"location":"modern-cpp/usability/#tail-type-inference","text":"\u524d\u9762\u63d0\u5230\u8aaa auto \u4e0d\u80fd\u7576\u4f5c\u51fd\u5f0f\u53c3\u6578\u7684\u985e\u578b\uff0c\u90a3\u80fd\u4e0d\u80fd\u7576\u4f5c\u8fd4\u56de\u578b\u614b\u5462\uff0cC++ 14 \u5f8c\u53ef\u4ee5 template<typename T, typename U> auto add(T x, U y){ return x + y; } tail type inference \u662f\u5728 C++14 \u4e4b\u524d\u56e0\u70ba\u51fd\u6578\u4e0d\u5177\u5099\u8fd4\u56de\u503c\u63a8\u5c0e\uff0c\u6240\u4ee5\u9700\u8981\u9019\u500b\u6a5f\u5236\u4f86\u6307\u5b9a\u8fd4\u56de\u578b\u614b template<typename T, typename U> auto add(T x, U y) -> decltype(\uff58+y){ return x + y; } \u81f3\u65bc\u70ba\u4ec0\u9ebc\u4e0d\u628a\u8fd4\u56de\u578b\u614b\u5beb\u6210 decltype(\uff58+y) \u5c31\u597d\u662f\u56e0\u70ba\u8b80\u5230\u524d\u9762\u662f\u7a0b\u5f0f\u9084\u4e0d\u77e5\u9053 x \u548c y \u662f\u4ec0\u9ebc","title":"tail type inference"},{"location":"modern-cpp/usability/#decltypeauto","text":"\u4f5c\u8005\u8868\u793a\u8981\u770b\u5b8c\u4e0b\u4e00\u7ae0\u6bd4\u8f03\u597d\u7406\u89e3","title":"decltype(auto) ??"}]}