{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Hi \u8a18\u9304\u4e00\u500b","title":"Home"},{"location":"#hi","text":"\u8a18\u9304\u4e00\u500b","title":"Hi"},{"location":"laradock/","text":"\u5728\u5beb Laravel \u4e4b\u524d\u7684\u74b0\u5883\u8a2d\u7f6e\u975e\u5e38\u7e41\u7463\uff0c\u800c\u4e14\u6700\u8fd1\u4e5f\u5728\u627e\u80fd\u5920\u8f15\u9b06\u67b6\u597d\u591a\u500b laravel \u5c08\u6848\u7684\u65b9\u6cd5\uff0c\u6240\u4ee5\u5c31\u4f86\u8a66\u8a66 Laradock\uff0c\u6709\u4e9b\u96f7\u6240\u4ee5\u9084\u662f\u8a18\u9304\u4e00\u4e0b git clone https://github.com/Laradock/laradock.git \u4fee\u6539 Laradock \u4e0b\u7684 .env cp env-example .env \u4f60\u5c08\u6848\u7684\u8def\u5f91 APP_CODE_PATH_HOST=/path/to/project APP_CODE_PATH_CONTAINER=/var/www \u5982\u6b64 /path/to/project \u6703\u5c0d\u61c9\u81f3 workspace \u7684 /var/www \uff0c\u5982\u679c\u4f60\u4e00\u6b21\u8981\u8dd1\u591a\u500b\u5c08\u6848\u53ef\u4ee5\u5c07\u4ed6\u5011\u90fd\u653e\u5230\u8a72\u8cc7\u6599\u593e\u4e0b Nginx .env NGINX_HOST_HTTP_PORT=80 NGINX_HOST_HTTPS_PORT=443 NGINX_SSL_PATH=./nginx/ssl/ nginx/sites \u4e0b\u7de8\u8f2f\u8a2d\u5b9a\u6a94 $ cp laravel.conf.example laravel.test.conf Mysql .env: MYSQL_USER , MYSQL_PASSWORD \u8981\u548c laravel \u4e0b\u7684 .env \u4e00\u6a23 MYSQL_DATABASE=dataset MYSQL_USER=default MYSQL_PASSWORD=secret MYSQL_ROOT_PASSWORD= laravel .env: DB_HOST \u6539\u70ba mysql DB_HOST=mysql \u5982\u679c\u4f60\u5e0c\u671b root \u5bc6\u78bc\u70ba\u7a7a\uff0c\u5728 docker-compose.yml \u4e2d\u65b0\u589e MYSQL_ALLOW_EMPTY_PASSWORD=true environment: - MYSQL_DATABASE=${MYSQL_DATABASE} - MYSQL_USER=${MYSQL_USER} - MYSQL_PASSWORD=${MYSQL_PASSWORD} - MYSQL_ALLOW_EMPTY_PASSWORD=true - MYSQL_ROOT_PASSWORD=${MYSQL_ROOT_PASSWORD} - TZ=${WORKSPACE_TIMEZONE} phpmyadmin .env: PMA_USER , PMA_PASSWORD \u8981\u548c laravel \u4e0b\u7684 .env \u4e00\u6a23 PMA_USER=default PMA_PASSWORD=secret PMA_ROOT_PASSWORD= ... PMA_PORT=8081 \u555f\u52d5 \u7b2c\u4e00\u6b21\u8dd1\u53ef\u80fd\u6703\u6709\u9ede\u4e45 docker-compose up -d nginx mysql phpmyadmin \u932f\u8aa4: \u9700\u8981\u5c07 docker \u66f4\u65b0\u5230\u6700\u65b0\u7248 Service 'mysql' failed to build: Please provide a source image with from prior to commit \u8a2d\u5b9a laravel \u7b49\u5230\u74b0\u5883\u90fd\u5f04\u597d\u5f8c\u5c31\u9032\u5165 container \u8a2d\u5b9a\u597d laravel project $ docker-compose exec workspace bash $ composer install ... migrate \u932f\u8aa41 php_network_getaddresses: getaddrinfo failed: nodename nor servname provided, or not known \u539f\u56e0\u662f\u672c\u5730\u4e0d\u77e5\u9053 mysql \u662f\u4ec0\u9ebc\uff0c\u9700\u8981\u6307\u5b9a DB_HOST \u70ba 127.0.0.1 $ env DB_HOST=127.0.0.1 php artisan migrate migrate \u932f\u8aa42 SQLSTATE[42000]: Syntax error or access violation: 1231 Variable 'sql_mode' can't be set to the value of 'NO_AUTO_CREATE_USER' \u9700\u8981\u4fee\u6539 laravel project \u7684 config/database.php\uff0c\u5c07 mysql \u7684 stict \u6539\u70ba false \u8dd1\u591a\u500b\u5c08\u6848 \u8981\u5c07\u591a\u500b project \u653e\u5230\u540c\u4e00\u53f0\u6a5f\u5668\u4e0a\u4e5f\u5f88\u7c21\u55ae\uff0c\u9996\u5148\u5728\u4f60\u7684 APP_CODE_PATH_HOST \u4e2d\u653e\u597d\u591a\u500b project /path/to/project - project1 - project2 \u7136\u5f8c\u53bb Laradock/nginx/sites \u4e0b\u591a\u5efa\u7acb\u591a\u500b\u8a2d\u5b9a\u64cb # project1.conf server { listen 80; listen [::]:80; server_name project1; root /var/www/project1/public; ... } # project2.conf server { listen 80; listen [::]:80; server_name project2; root /var/www/project2/public; ... } \u5982\u679c\u662f\u5728\u672c\u5730\u6e2c\u8a66\u5728 /etc/hosts \u52a0\u4e0a 127.0.0.1 project1 127.0.0.1 project2 \u518d\u4f86\u8981\u65b0\u589e\u591a\u500b database \uff0c\u4e0a\u7db2\u67e5\u4e86\u4e0b\u597d\u50cf\u6c92\u6709\u8f15\u9b06\u7684\u65b9\u6cd5\u53ef\u4ee5\u76f4\u63a5\u5efa\u7acb\u591a\u500b database\uff0c\u9700\u8981\u5728 Laradock/mysql/docker-entrypoint-initdb.d \u4e0b\u5beb\u8173\u672c\u8b93 container \u5efa\u7acb\u6642\u57f7\u884c\uff0c\u65e2\u7136\u90fd\u8981\u5728\u9019\u908a\u5beb\u8173\u672c\u4e86\uff0c\u4e7e\u8106\u6240\u6709\u6703\u7528\u5230\u7684\u8cc7\u6599\u5eab\u90fd\u5728\u9019\u908a\u8a2d\u5b9a\u597d\uff0c\u4e0a\u8ff0\u7684\u8a2d\u5b9a\u64cb\u5c31\u586b\u500b dummy database \u548c user # createdb.sql CREATE DATABASE IF NOT EXISTS `project1`; CREATE DATABASE IF NOT EXISTS `project2`; CREATE USER 'user1'@'%' IDENTIFIED BY 'user1'; CREATE USER 'user2'@'%' IDENTIFIED BY 'user2'; GRANT ALL ON `project1`.* TO 'user1'@'%'; GRANT ALL ON `project2`.* TO 'user2'@'%'; \u8a18\u5f97\u5728 mysql \u8a2d\u5b9a\u6709\u66f4\u52d5\u5f8c\u522a\u6389\u8cc7\u6599\u518d\u91cd\u5efa $ rm -Rf ~/.laradock/data/mysql \u5982\u6b64\u5c31\u67b6\u597d\u591a\u500b laravel \u5c08\u6848\u62c9\uff0c\u5982\u679c https \u9700\u8981\u6191\u8b49\u53ef\u4ee5\u4f7f\u7528 cerbot\uff0c\u6703\u81ea\u52d5\u5e6b\u4f60\u53bb letsencrypt \u7533\u8acb\u6191\u8b49\uff0c\u518d\u5c07 cerbot \u5b58\u653e\u6191\u8b49\u7684\u4f4d\u5740\u548c nginx \u9023\u901a\u5373\u53ef\u3002","title":"Laradock"},{"location":"laradock/#laradock-env","text":"cp env-example .env \u4f60\u5c08\u6848\u7684\u8def\u5f91 APP_CODE_PATH_HOST=/path/to/project APP_CODE_PATH_CONTAINER=/var/www \u5982\u6b64 /path/to/project \u6703\u5c0d\u61c9\u81f3 workspace \u7684 /var/www \uff0c\u5982\u679c\u4f60\u4e00\u6b21\u8981\u8dd1\u591a\u500b\u5c08\u6848\u53ef\u4ee5\u5c07\u4ed6\u5011\u90fd\u653e\u5230\u8a72\u8cc7\u6599\u593e\u4e0b","title":"\u4fee\u6539 Laradock \u4e0b\u7684 .env"},{"location":"laradock/#nginx","text":".env NGINX_HOST_HTTP_PORT=80 NGINX_HOST_HTTPS_PORT=443 NGINX_SSL_PATH=./nginx/ssl/ nginx/sites \u4e0b\u7de8\u8f2f\u8a2d\u5b9a\u6a94 $ cp laravel.conf.example laravel.test.conf","title":"Nginx"},{"location":"laradock/#mysql","text":".env: MYSQL_USER , MYSQL_PASSWORD \u8981\u548c laravel \u4e0b\u7684 .env \u4e00\u6a23 MYSQL_DATABASE=dataset MYSQL_USER=default MYSQL_PASSWORD=secret MYSQL_ROOT_PASSWORD= laravel .env: DB_HOST \u6539\u70ba mysql DB_HOST=mysql \u5982\u679c\u4f60\u5e0c\u671b root \u5bc6\u78bc\u70ba\u7a7a\uff0c\u5728 docker-compose.yml \u4e2d\u65b0\u589e MYSQL_ALLOW_EMPTY_PASSWORD=true environment: - MYSQL_DATABASE=${MYSQL_DATABASE} - MYSQL_USER=${MYSQL_USER} - MYSQL_PASSWORD=${MYSQL_PASSWORD} - MYSQL_ALLOW_EMPTY_PASSWORD=true - MYSQL_ROOT_PASSWORD=${MYSQL_ROOT_PASSWORD} - TZ=${WORKSPACE_TIMEZONE}","title":"Mysql"},{"location":"laradock/#phpmyadmin","text":".env: PMA_USER , PMA_PASSWORD \u8981\u548c laravel \u4e0b\u7684 .env \u4e00\u6a23 PMA_USER=default PMA_PASSWORD=secret PMA_ROOT_PASSWORD= ... PMA_PORT=8081","title":"phpmyadmin"},{"location":"laradock/#_1","text":"\u7b2c\u4e00\u6b21\u8dd1\u53ef\u80fd\u6703\u6709\u9ede\u4e45 docker-compose up -d nginx mysql phpmyadmin \u932f\u8aa4: \u9700\u8981\u5c07 docker \u66f4\u65b0\u5230\u6700\u65b0\u7248 Service 'mysql' failed to build: Please provide a source image with from prior to commit","title":"\u555f\u52d5"},{"location":"laradock/#laravel","text":"\u7b49\u5230\u74b0\u5883\u90fd\u5f04\u597d\u5f8c\u5c31\u9032\u5165 container \u8a2d\u5b9a\u597d laravel project $ docker-compose exec workspace bash $ composer install ... migrate \u932f\u8aa41 php_network_getaddresses: getaddrinfo failed: nodename nor servname provided, or not known \u539f\u56e0\u662f\u672c\u5730\u4e0d\u77e5\u9053 mysql \u662f\u4ec0\u9ebc\uff0c\u9700\u8981\u6307\u5b9a DB_HOST \u70ba 127.0.0.1 $ env DB_HOST=127.0.0.1 php artisan migrate migrate \u932f\u8aa42 SQLSTATE[42000]: Syntax error or access violation: 1231 Variable 'sql_mode' can't be set to the value of 'NO_AUTO_CREATE_USER' \u9700\u8981\u4fee\u6539 laravel project \u7684 config/database.php\uff0c\u5c07 mysql \u7684 stict \u6539\u70ba false","title":"\u8a2d\u5b9a laravel"},{"location":"laradock/#_2","text":"\u8981\u5c07\u591a\u500b project \u653e\u5230\u540c\u4e00\u53f0\u6a5f\u5668\u4e0a\u4e5f\u5f88\u7c21\u55ae\uff0c\u9996\u5148\u5728\u4f60\u7684 APP_CODE_PATH_HOST \u4e2d\u653e\u597d\u591a\u500b project /path/to/project - project1 - project2 \u7136\u5f8c\u53bb Laradock/nginx/sites \u4e0b\u591a\u5efa\u7acb\u591a\u500b\u8a2d\u5b9a\u64cb # project1.conf server { listen 80; listen [::]:80; server_name project1; root /var/www/project1/public; ... } # project2.conf server { listen 80; listen [::]:80; server_name project2; root /var/www/project2/public; ... } \u5982\u679c\u662f\u5728\u672c\u5730\u6e2c\u8a66\u5728 /etc/hosts \u52a0\u4e0a 127.0.0.1 project1 127.0.0.1 project2 \u518d\u4f86\u8981\u65b0\u589e\u591a\u500b database \uff0c\u4e0a\u7db2\u67e5\u4e86\u4e0b\u597d\u50cf\u6c92\u6709\u8f15\u9b06\u7684\u65b9\u6cd5\u53ef\u4ee5\u76f4\u63a5\u5efa\u7acb\u591a\u500b database\uff0c\u9700\u8981\u5728 Laradock/mysql/docker-entrypoint-initdb.d \u4e0b\u5beb\u8173\u672c\u8b93 container \u5efa\u7acb\u6642\u57f7\u884c\uff0c\u65e2\u7136\u90fd\u8981\u5728\u9019\u908a\u5beb\u8173\u672c\u4e86\uff0c\u4e7e\u8106\u6240\u6709\u6703\u7528\u5230\u7684\u8cc7\u6599\u5eab\u90fd\u5728\u9019\u908a\u8a2d\u5b9a\u597d\uff0c\u4e0a\u8ff0\u7684\u8a2d\u5b9a\u64cb\u5c31\u586b\u500b dummy database \u548c user # createdb.sql CREATE DATABASE IF NOT EXISTS `project1`; CREATE DATABASE IF NOT EXISTS `project2`; CREATE USER 'user1'@'%' IDENTIFIED BY 'user1'; CREATE USER 'user2'@'%' IDENTIFIED BY 'user2'; GRANT ALL ON `project1`.* TO 'user1'@'%'; GRANT ALL ON `project2`.* TO 'user2'@'%'; \u8a18\u5f97\u5728 mysql \u8a2d\u5b9a\u6709\u66f4\u52d5\u5f8c\u522a\u6389\u8cc7\u6599\u518d\u91cd\u5efa $ rm -Rf ~/.laradock/data/mysql \u5982\u6b64\u5c31\u67b6\u597d\u591a\u500b laravel \u5c08\u6848\u62c9\uff0c\u5982\u679c https \u9700\u8981\u6191\u8b49\u53ef\u4ee5\u4f7f\u7528 cerbot\uff0c\u6703\u81ea\u52d5\u5e6b\u4f60\u53bb letsencrypt \u7533\u8acb\u6191\u8b49\uff0c\u518d\u5c07 cerbot \u5b58\u653e\u6191\u8b49\u7684\u4f4d\u5740\u548c nginx \u9023\u901a\u5373\u53ef\u3002","title":"\u8dd1\u591a\u500b\u5c08\u6848"},{"location":"linux-kernel/others/","text":"Virtual Memory Areas(VMA) struct mm_struct \u4e2d\u6709\u4e00\u500b\u7a31\u70ba mmap \u7684 field\uff0c mmap \u7684\u578b\u614b\u70ba struct vm_area_struct Linux \u4ee5 struct vm_area_struct \u8cc7\u6599\u7d50\u69cb\u4f86\u7d00\u9304\u6bcf\u4e00\u300c\u5340\u584a\u300d\u7684 VMA \u8cc7\u8a0a VMA \u662f user process \u88e1\u4e00\u6bb5 virtual address space \u5340\u584a\uff0cvirtual address space \u662f\u9023\u7e8c\u7684\u8a18\u61b6\u9ad4\u7a7a\u9593\uff0c\u7576\u7136 VMA \u4e5f\u6703\u662f\u9023\u7e8c\u7684\u7a7a\u9593\u3002VMA \u5c0d Linux \u7684\u4e3b\u8981\u597d\u8655\u662f\uff0c\u53ef\u4ee5\u8a18\u61b6\u9ad4\u7684\u4f7f\u7528\u66f4\u6709\u6548\u7387\uff0c\u4e26\u4e14\u66f4\u5bb9\u6613\u7ba1\u7406 user process address space\u3002 \u5f9e\u53e6\u4e00\u500b\u89c0\u5ff5\u4f86\u770b\uff0cVMA \u53ef\u4ee5\u8b93 Linux kernel \u4ee5 process \u7684\u89d2\u5ea6\u4f86\u7ba1\u7406 virtual address space\u3002Process \u7684 VMA \u5c0d\u6620\uff0c\u53ef\u4ee5\u7531 /proc/ /maps \u6a94\u6848\u67e5\u8a62 src: http://www.jollen.org/blog/2007/01/linux_virtual_memory_areas_vma.html struct vm_area_struct { struct mm_struct * vm_mm; unsigned long vm_start; unsigned long vm_end; struct vm_area_struct *vm_next; pgprot_t vm_page_prot; unsigned long vm_flags; rb_node_t vm_rb; struct vm_area_struct *vm_next_share; struct vm_area_struct **vm_pprev_share; struct vm_operations_struct * vm_ops; unsigned long vm_pgoff; struct file * vm_file; unsigned long vm_raend; void * vm_private_data; }; Linux Paging Linux\u4e2d\u63a1\u7528\u4e86\u4e00\u7a2e\u901a\u7528\u7684\u56db\u7d1a\u5206\u9801\u6a5f\u5236 Page Global Directory \u8cc7\u6599\u7d50\u69cb\u70ba pgd_t Page Upper Directory pmd_t Page Middle Directory pud_t Page Table pte_t \u5728\u9019\u7a2e\u5206\u9801\u6a5f\u5236\u4e0b\uff0c\u4e00\u500b\u5b8c\u6574\u7684\u7dda\u6027\u5730\u5740\u88ab\u5206\u70ba\u4e94\u90e8\u5206\uff1a \u9801\u5168\u5c40\u76ee\u9304+\u9801\u4e0a\u7d1a\u76ee\u9304+\u9801\u4e2d\u9593\u76ee\u9304+\u9801\u8868+\u504f\u79fb\u91cf \u4e0d\u7ba1\u7cfb\u7d71\u63a1\u7528\u591a\u5c11\u7d1a\u5206\u9801\u6a21\u578b\uff0c\u7dda\u6027\u5730\u5740\u672c\u8cea\u4e0a\u90fd\u662f\u7d22\u5f15+\u504f\u79fb\u91cf\u7684\u5f62\u5f0f\uff0c\u751a\u81f3\u4f60\u53ef\u4ee5\u5c07\u6574\u500b\u7dda\u6027\u5730\u5740\u770b\u4f5cN+1\u500b\u7d22\u5f15\u7684\u7d44\u5408\uff0cN\u662f\u7cfb\u7d71\u63a1\u7528\u7684\u5206\u9801\u7d1a\u6578\u3002\u5728\u56db\u7d1a\u5206\u9801\u6a21\u578b\u4e0b\uff0c\u7dda\u6027\u5730\u5740\u88ab\u5206\u70ba5\u90e8\u5206 src: http://edsionte.com/techblog/archives/3435 \u865b\u64ec\u5730\u5740\u8f49\u7269\u7406 : Step 1 \u5f9e CR3 register \u4e2d\u8b80\u53d6 pgd \u6240\u5728\u7269\u7406\u5730\u5740\u7684\u57fa\u5740\uff0c\u5f9e linear address \u7684\u7b2c\u4e00\u90e8\u5206\u7372\u53d6 pgd \u7684\u7d22\u5f15\uff0c\u5169\u8005\u76f8\u52a0\u5373\u662f virtual address \u5728 pgd \u4e2d\u5c0d\u61c9\u6b04\u7684\u7dda\u6027\u5730\u5740 arch/x86/include/asm/pgtable_64_types.h /* * PGDIR_SHIFT determines what a top-level page table entry can map */ #define PGDIR_SHIFT 39 #define PTRS_PER_PGD 512 arch/x86/include/asm/pgtable.h #define pgd_index(address) (((address) >> PGDIR_SHIFT) & (PTRS_PER_PGD - 1)) #define pgd_offset(mm, address) ((mm)->pgd + pgd_index((address))) \u5176\u4e2dPGDIR_SHIFT 39 \u662f pmd(9)+pud(9)+pte(9)+offset(12) PGD\uff0cPUD\uff0cPMD\uff0cPTE\u5206\u5225\u90fd\u662f\u4e00\u500b4k\u7684page\uff0cPGD\uff0cPUD\uff0cPMD\uff0cPTE\u662f\u56db\u5f35table\uff0ctable\u7684\u5927\u5c0f\u90fd\u662f4k\uff0c\u5176\u4e2dtable\u7684entry\u5206\u5225\u662f: pgd_t, pud_t, pmd_t, pte_t,\u90fd\u662funsigned long\u985e\u578b\uff088\u500b\u5b57\u7bc0\uff09\uff0c4k\uff082\u768412\u6b21\u65b9\uff09/8\u5b57\u7bc0\uff082\u76843\u6b21\u65b9\uff09= 512\u500bentry\uff082\u76849\u6b21\u65b9\uff09 Step 2 pgd_val(pgd) \u53d6\u5f97 pgd \u4e2d\u90a3\u6b04\u6240\u6307\u5230\u7684\u503c\uff0c\u5b83\u8207 PTE_PFN_MASK \u8a08\u7b97\u5f8c\u518d\u4e1f\u5230 __va() \u5373\u5f97\u5230 pud \u6240\u5728\u7269\u7406\u5730\u5740\u7684\u57fa\u5740\uff0c\u5f9e linear address \u7684\u7b2c\u4e00\u90e8\u5206\u7372\u53d6 pud \u7684\u7d22\u5f15\uff0c\u5169\u8005\u76f8\u52a0\u5373\u662f virtual address \u5728 pud \u4e2d\u5c0d\u61c9\u6b04\u7684\u7dda\u6027\u5730\u5740 arch/x86/include/asm/pgtable_64_types.h /* * 3rd level page */ #define PUD_SHIFT 30 #define PTRS_PER_PUD 512 arch/x86/include/asm/pgtable_types.h /* Extracts the PFN from a (pte|pmd|pud|pgd)val_t of a 4KB page */ #define PTE_PFN_MASK ((pteval_t)PHYSICAL_PAGE_MASK) arch/x86/include/asm/pgtable.h static inline unsigned long pgd_page_vaddr(pgd_t pgd) { return (unsigned long)__va((unsigned long)pgd_val(pgd) & PTE_PFN_MASK); } /* to find an entry in a page-table-directory. */ static inline unsigned long pud_index(unsigned long address) { return (address >> PUD_SHIFT) & (PTRS_PER_PUD - 1); } static inline pud_t *pud_offset(pgd_t *pgd, unsigned long address) { return (pud_t *)pgd_page_vaddr(*pgd) + pud_index(address); } arch/x86/include/asm/page.h #define __va(x) ((void *)((unsigned long)(x)+PAGE_OFFSET)) \u5f8c\u9762\u6b65\u9a5f\u90fd\u5dee\u4e0d\u591a\uff0c\u6700\u7d42\u62ff\u5230 pte \u4e2d\u5c0d\u61c9\u6b04\u7684\u7dda\u6027\u5730\u5740\u518d\u7528 page_addr = pte_val(*pte) & PTE_PFN_MASK & PAGE_MASK; page_offset = vaddr & ~PAGE_MASK; paddr = page_addr | page_offset; copy-on-write \u7576\u6211\u5011 fork() \u6642\uff0c\u6703\u7522\u751f\u4e00\u500b\u548c\u7236\u9032\u7a0b\u5b8c\u5168\u76f8\u540c\u7684\u5b50\u9032\u7a0b(\u9664\u4e86pid) \u5982\u679c\u6309\u50b3\u7d71\u7684\u505a\u6cd5\uff0c\u6703\u76f4\u63a5\u5c07\u7236\u9032\u7a0b\u7684\u6578\u64da\u62f7\u8c9d\u5230\u5b50\u9032\u7a0b\u4e2d\uff0c\u62f7\u8c9d\u5b8c\u4e4b\u5f8c\uff0c\u7236\u9032\u7a0b\u548c\u5b50\u9032\u7a0b\u4e4b\u9593\u7684 \u6578\u64da\u6bb5 \u548c \u5806\u68e7 \u662f\u76f8\u4e92\u7368\u7acb\u7684 \u4f46\u662f\uff0c\u901a\u5e38\u5b50\u9032\u7a0b\u90fd\u6703\u57f7\u884c exec() \u4f86\u505a\u81ea\u5df1\u60f3\u8981\u5be6\u73fe\u7684\u529f\u80fd\u3002 exec() exec\u51fd\u6578\u7684\u4f5c\u7528\u5c31\u662f\uff1a\u88dd\u8f09\u4e00\u500b\u65b0\u7684\u7a0b\u5e8f\uff08\u53ef\u57f7\u884c\u6620\u50cf\uff09\u8986\u84cb\u7576\u524d\u9032\u7a0b\u5167\u5b58\u7a7a\u9593\u4e2d\u7684\u6620\u50cf\uff0c\u5f9e\u800c\u57f7\u884c\u4e0d\u540c\u7684\u4efb\u52d9\u3002 exec\u7cfb\u5217\u51fd\u6578\u5728\u57f7\u884c\u6642\u6703\u76f4\u63a5\u66ff\u63db\u6389\u7576\u524d\u9032\u7a0b\u7684\u5730\u5740\u7a7a\u9593\u3002 \u6240\u4ee5\uff0c\u5982\u679c\u6309\u7167\u50b3\u7d71\u505a\u6cd5\u7684\u8a71\uff0c\u5275\u5efa\u5b50\u9032\u7a0b\u6642\u5fa9\u88fd\u904e\u53bb\u7684\u6578\u64da\u662f\u6c92\u7528\u7684(\u56e0\u70ba\u5b50\u9032\u7a0b\u57f7\u884cexec()\uff0c\u539f\u6709\u7684\u6578\u64da\u6703\u88ab\u6e05\u7a7a)\uff0c\u65e2\u7136\u5f88\u591a\u6642\u5019\u8907\u88fd\u7d66\u5b50\u9032\u7a0b\u7684\u6578\u64da\u662f\u7121\u6548\u7684\uff0c\u65bc\u662f\u5c31\u6709\u4e86Copy On Write\u9019\u9805\u6280\u8853\u4e86 fork\u5275\u5efa\u51fa\u7684\u5b50\u9032\u7a0b\uff0c\u8207\u7236\u9032\u7a0b\u5171\u4eab\u5167\u5b58\u7a7a\u9593\u3002\u4e5f\u5c31\u662f\u8aaa\uff0c\u5982\u679c\u5b50\u9032\u7a0b\u4e0d\u5c0d\u5167\u5b58\u7a7a\u9593\u9032\u884c\u5beb\u5165\u64cd\u4f5c\u7684\u8a71\uff0c\u5167\u5b58\u7a7a\u9593\u4e2d\u7684\u6578\u64da\u4e26\u4e0d\u6703\u5fa9\u5236\u7d66\u5b50\u9032\u7a0b \u4e26\u4e14\u5982\u679c\u5728fork\u51fd\u6578\u8fd4\u56de\u4e4b\u5f8c\uff0c\u5b50\u9032\u7a0b\u7b2c\u4e00\u6642\u9593 exec\u4e00\u500b\u65b0\u7684\u53ef\u57f7\u884c\u6620\u50cf\uff0c\u90a3\u9ebc\u4e5f\u4e0d\u6703\u6d6a\u8cbb\u6642\u9593\u548c\u5167\u5b58\u7a7a\u9593 \u7d50\u8ad6: \u5728fork\u4e4b\u5f8cexec\u4e4b\u524d\u5169\u500b\u9032\u7a0b\u7528\u7684\u662f\u76f8\u540c\u7684\u7269\u7406\u7a7a\u9593\uff08\u5167\u5b58\u5340\uff09\uff0c\u5b50\u9032\u7a0b\u7684\u4ee3\u78bc\u6bb5\u3001\u6578\u64da\u6bb5\u3001\u5806\u68e7\u90fd\u662f\u6307\u5411\u7236\u9032\u7a0b\u7684\u7269\u7406\u7a7a\u9593\uff0c\u4e5f\u5c31\u662f\u8aaa\uff0c \u5169\u8005\u7684\u865b\u64ec\u7a7a\u9593\u4e0d\u540c\uff0c\u4f46\u5176\u5c0d\u61c9\u7684\u7269\u7406\u7a7a\u9593\u662f\u540c\u4e00\u500b \u7576\u7236\u5b50\u9032\u7a0b\u4e2d \u6709\u66f4\u6539\u76f8\u61c9\u6bb5\u7684\u884c\u70ba\u767c\u751f\u6642\uff0c\u518d\u70ba\u5b50\u9032\u7a0b\u76f8\u61c9\u7684\u6bb5\u5206\u914d\u7269\u7406\u7a7a\u9593 \u5982\u679c\u4e0d\u662f\u56e0\u70baexec\uff0c\u5167\u6838\u6703\u7d66 \u5b50\u9032\u7a0b\u7684\u6578\u64da\u6bb5\u3001\u5806\u68e7\u6bb5\u5206\u914d\u76f8\u61c9\u7684\u7269\u7406\u7a7a\u9593 \uff08\u81f3\u6b64\u5169\u8005\u6709\u5404\u81ea\u7684\u9032\u7a0b\u7a7a\u9593\uff0c\u4e92\u4e0d\u5f71\u97ff\uff09\uff0c\u800c\u4ee3\u78bc\u6bb5\u7e7c\u7e8c\u5171\u4eab\u7236\u9032\u7a0b\u7684\u7269\u7406\u7a7a\u9593\uff08\u5169\u8005\u7684\u4ee3\u78bc\u5b8c\u5168\u76f8\u540c\uff09\u3002 \u800c\u5982\u679c\u662f\u56e0\u70baexec\uff0c\u7531\u65bc\u5169\u8005\u57f7\u884c\u7684\u4ee3\u78bc\u4e0d\u540c\uff0c\u5b50\u9032\u7a0b\u7684\u4ee3\u78bc\u6bb5\u4e5f\u6703\u5206\u914d\u55ae\u7368\u7684\u7269\u7406\u7a7a\u9593\u3002 \u5be6\u6e2c\u5f8c:(\u552f\u4e00\u5dee\u5225\u662fvirtual address\u90fd\u4e00\u6a23\uff0c\u6c92\u6709\u50cf\u4e0a\u9762\u8aaa\u7684\u90fd\u6703\u4e0d\u540c) if not write: phyiscal address same else if no exec: data, stack, heap segment different code segment same if exec: all different http://eastrivervillage.com/The-Linux-COW/ asmlinkage | fastcall linux \u652f\u6301\u591a\u7a2eCPU\u67b6\u69cb\uff0c\u6bd4\u5982x86\u3001ppc\u548carm\u7b49\uff0c\u5728\u4e0d\u540c\u7684\u8655\u7406\u5668\u7d50\u69cb\u4e0a\u53c3\u6578\u7684\u50b3\u905e\u65b9\u5f0f\u90fd\u4e0d\u540c\uff0c\u4f8b\u5982 x86\u7684\u51fd\u6578\u53c3\u6578\u548c\u51fd\u6578\u5167\u90e8\u5c40\u90e8\u8b8a\u91cf\u6703\u88ab\u5206\u914d\u5230\u51fd\u6578\u7684stack\u4e2d arm\u5247\u662f\u5c0d\u51fd\u6578\u8abf\u7528\u904e\u7a0b\u4e2d\u7684\u50b3\u53c3\u5b9a\u7fa9\u4e86\u4e00\u5957\u898f\u5247\uff0c\u5373ATPCS\uff0c\u898f\u5247\u4e2d\u660e\u78ba\u6307\u51faARM\u4e2dR0-R4\u90fd\u662f\u4f5c\u70ba\u901a\u7528\u5bc4\u5b58\u5668\u4f7f\u7528\uff0c\u5728\u51fd\u6578\u8abf\u7528\u6642\u8655\u7406\u5668\u5f9eR0-R4\u4e2d\u7372\u53d6\u53c3\u6578\uff0c\u5728\u51fd\u6578\u8fd4\u56de\u6642\u518d\u5c07\u9700\u8981\u8fd4\u56de\u7684\u53c3\u6578\u4e00\u6b21\u5b58\u5230R0-R4\u4e2d\uff0c\u4e5f\u5c31\u662f\u8aaa\u53ef\u4ee5\u5c07\u51fd\u6578\u53c3\u6578\u76f4\u63a5\u5b58\u653e\u5728\u5bc4\u5b58\u5668\u4e2d \u6240\u4ee5\u70ba\u4e86\u56b4\u683c\u5340\u5225\u51fd\u6578\u53c3\u6578\u7684\u5b58\u653e\u4f4d\u7f6e\uff0c\u5f15\u5165\u4e86\u5169\u500b\u6a19\u8a18 asmlinkage \u8868\u793a\u5c07\u51fd\u6578\u53c3\u6578\u5b58\u653e\u5728stack\u4e2d FASTCALL \u662f\u901a\u77e5\u7de8\u8b6f\u5668\u5c07\u51fd\u6578\u53c3\u6578\u7528\u5bc4\u5b58\u5668\u4fdd\u5b58\u8d77\u4f86 #define asmlinkage CPP_ASMLINKAGE __attribute__((regparm(0))) #define FASTCALL(x) x __attribute__((regparm(3))) #define fastcall __attribute__((regparm(3))) attribute ((regparm(0)))\uff1a\u544a\u8a34gcc\u7de8\u8b6f\u5668\u8a72\u51fd\u6578\u4e0d\u9700\u8981\u901a\u904e\u4efb\u4f55\u5bc4\u5b58\u5668\u4f86\u50b3\u905e\u53c3\u6578\uff0c\u53c3\u6578\u53ea\u662f\u901a\u904e\u5806\u68e7\u4f86\u50b3\u905e\u3002 attribute ((regparm(3)))\uff1a\u544a\u8a34gcc\u7de8\u8b6f\u5668\u9019\u500b\u51fd\u6578\u53ef\u4ee5\u901a\u904e\u5bc4\u5b58\u5668\u50b3\u905e\u591a\u90543\u500b\u7684\u53c3\u6578\uff0c\u90193\u500b\u5bc4\u5b58\u5668\u4f9d\u6b21\u70baEAX\u3001EDX\u548cECX\u3002\u66f4\u591a\u7684\u53c3\u6578\u624d\u901a\u904e\u5806\u68e7\u50b3\u905e\u3002\u9019\u6a23\u53ef\u4ee5\u6e1b\u5c11\u4e00\u4e9b\u5165\u68e7\u51fa\u68e7\u64cd\u4f5c\uff0c\u56e0\u6b64\u8abf\u7528\u6bd4\u8f03\u5feb\u3002 modules buildin module obj-y += filename.o \u7de8\u8b6f\u7684\u6642\u5019\u5c31\u6703\u5728\u5c0d\u61c9\u76ee\u9304\u7522\u751fbuilt-in.o\u7684\u6a94\u6848 \u9019\u4e9b\u6a94\u6848\u4fbf\u6703\u88ab\u5305\u5165\u5728image\u88e1\u9762 externel module obj-m += filename.o \u7de8\u8b6f\u7684\u6642\u5019\u5c31\u6703\u5728\u5c0d\u61c9\u76ee\u9304\u7522\u751f kernel/time/test_udelay.ko \u7684\u6a94\u6848 \u9019\u4e9b\u6a94\u6848\u4fbf\u6703\u88ab\u653e\u7f6e\u5728 /lib/modules/$(uname -r) http://yi-jyun.blogspot.com/2017/07/linux-kernel-modules.html","title":"others"},{"location":"linux-kernel/others/#virtual-memory-areasvma","text":"struct mm_struct \u4e2d\u6709\u4e00\u500b\u7a31\u70ba mmap \u7684 field\uff0c mmap \u7684\u578b\u614b\u70ba struct vm_area_struct Linux \u4ee5 struct vm_area_struct \u8cc7\u6599\u7d50\u69cb\u4f86\u7d00\u9304\u6bcf\u4e00\u300c\u5340\u584a\u300d\u7684 VMA \u8cc7\u8a0a VMA \u662f user process \u88e1\u4e00\u6bb5 virtual address space \u5340\u584a\uff0cvirtual address space \u662f\u9023\u7e8c\u7684\u8a18\u61b6\u9ad4\u7a7a\u9593\uff0c\u7576\u7136 VMA \u4e5f\u6703\u662f\u9023\u7e8c\u7684\u7a7a\u9593\u3002VMA \u5c0d Linux \u7684\u4e3b\u8981\u597d\u8655\u662f\uff0c\u53ef\u4ee5\u8a18\u61b6\u9ad4\u7684\u4f7f\u7528\u66f4\u6709\u6548\u7387\uff0c\u4e26\u4e14\u66f4\u5bb9\u6613\u7ba1\u7406 user process address space\u3002 \u5f9e\u53e6\u4e00\u500b\u89c0\u5ff5\u4f86\u770b\uff0cVMA \u53ef\u4ee5\u8b93 Linux kernel \u4ee5 process \u7684\u89d2\u5ea6\u4f86\u7ba1\u7406 virtual address space\u3002Process \u7684 VMA \u5c0d\u6620\uff0c\u53ef\u4ee5\u7531 /proc/ /maps \u6a94\u6848\u67e5\u8a62 src: http://www.jollen.org/blog/2007/01/linux_virtual_memory_areas_vma.html struct vm_area_struct { struct mm_struct * vm_mm; unsigned long vm_start; unsigned long vm_end; struct vm_area_struct *vm_next; pgprot_t vm_page_prot; unsigned long vm_flags; rb_node_t vm_rb; struct vm_area_struct *vm_next_share; struct vm_area_struct **vm_pprev_share; struct vm_operations_struct * vm_ops; unsigned long vm_pgoff; struct file * vm_file; unsigned long vm_raend; void * vm_private_data; };","title":"Virtual Memory Areas(VMA)"},{"location":"linux-kernel/others/#linux-paging","text":"Linux\u4e2d\u63a1\u7528\u4e86\u4e00\u7a2e\u901a\u7528\u7684\u56db\u7d1a\u5206\u9801\u6a5f\u5236 Page Global Directory \u8cc7\u6599\u7d50\u69cb\u70ba pgd_t Page Upper Directory pmd_t Page Middle Directory pud_t Page Table pte_t \u5728\u9019\u7a2e\u5206\u9801\u6a5f\u5236\u4e0b\uff0c\u4e00\u500b\u5b8c\u6574\u7684\u7dda\u6027\u5730\u5740\u88ab\u5206\u70ba\u4e94\u90e8\u5206\uff1a \u9801\u5168\u5c40\u76ee\u9304+\u9801\u4e0a\u7d1a\u76ee\u9304+\u9801\u4e2d\u9593\u76ee\u9304+\u9801\u8868+\u504f\u79fb\u91cf \u4e0d\u7ba1\u7cfb\u7d71\u63a1\u7528\u591a\u5c11\u7d1a\u5206\u9801\u6a21\u578b\uff0c\u7dda\u6027\u5730\u5740\u672c\u8cea\u4e0a\u90fd\u662f\u7d22\u5f15+\u504f\u79fb\u91cf\u7684\u5f62\u5f0f\uff0c\u751a\u81f3\u4f60\u53ef\u4ee5\u5c07\u6574\u500b\u7dda\u6027\u5730\u5740\u770b\u4f5cN+1\u500b\u7d22\u5f15\u7684\u7d44\u5408\uff0cN\u662f\u7cfb\u7d71\u63a1\u7528\u7684\u5206\u9801\u7d1a\u6578\u3002\u5728\u56db\u7d1a\u5206\u9801\u6a21\u578b\u4e0b\uff0c\u7dda\u6027\u5730\u5740\u88ab\u5206\u70ba5\u90e8\u5206 src: http://edsionte.com/techblog/archives/3435 \u865b\u64ec\u5730\u5740\u8f49\u7269\u7406 : Step 1 \u5f9e CR3 register \u4e2d\u8b80\u53d6 pgd \u6240\u5728\u7269\u7406\u5730\u5740\u7684\u57fa\u5740\uff0c\u5f9e linear address \u7684\u7b2c\u4e00\u90e8\u5206\u7372\u53d6 pgd \u7684\u7d22\u5f15\uff0c\u5169\u8005\u76f8\u52a0\u5373\u662f virtual address \u5728 pgd \u4e2d\u5c0d\u61c9\u6b04\u7684\u7dda\u6027\u5730\u5740 arch/x86/include/asm/pgtable_64_types.h /* * PGDIR_SHIFT determines what a top-level page table entry can map */ #define PGDIR_SHIFT 39 #define PTRS_PER_PGD 512 arch/x86/include/asm/pgtable.h #define pgd_index(address) (((address) >> PGDIR_SHIFT) & (PTRS_PER_PGD - 1)) #define pgd_offset(mm, address) ((mm)->pgd + pgd_index((address))) \u5176\u4e2dPGDIR_SHIFT 39 \u662f pmd(9)+pud(9)+pte(9)+offset(12) PGD\uff0cPUD\uff0cPMD\uff0cPTE\u5206\u5225\u90fd\u662f\u4e00\u500b4k\u7684page\uff0cPGD\uff0cPUD\uff0cPMD\uff0cPTE\u662f\u56db\u5f35table\uff0ctable\u7684\u5927\u5c0f\u90fd\u662f4k\uff0c\u5176\u4e2dtable\u7684entry\u5206\u5225\u662f: pgd_t, pud_t, pmd_t, pte_t,\u90fd\u662funsigned long\u985e\u578b\uff088\u500b\u5b57\u7bc0\uff09\uff0c4k\uff082\u768412\u6b21\u65b9\uff09/8\u5b57\u7bc0\uff082\u76843\u6b21\u65b9\uff09= 512\u500bentry\uff082\u76849\u6b21\u65b9\uff09 Step 2 pgd_val(pgd) \u53d6\u5f97 pgd \u4e2d\u90a3\u6b04\u6240\u6307\u5230\u7684\u503c\uff0c\u5b83\u8207 PTE_PFN_MASK \u8a08\u7b97\u5f8c\u518d\u4e1f\u5230 __va() \u5373\u5f97\u5230 pud \u6240\u5728\u7269\u7406\u5730\u5740\u7684\u57fa\u5740\uff0c\u5f9e linear address \u7684\u7b2c\u4e00\u90e8\u5206\u7372\u53d6 pud \u7684\u7d22\u5f15\uff0c\u5169\u8005\u76f8\u52a0\u5373\u662f virtual address \u5728 pud \u4e2d\u5c0d\u61c9\u6b04\u7684\u7dda\u6027\u5730\u5740 arch/x86/include/asm/pgtable_64_types.h /* * 3rd level page */ #define PUD_SHIFT 30 #define PTRS_PER_PUD 512 arch/x86/include/asm/pgtable_types.h /* Extracts the PFN from a (pte|pmd|pud|pgd)val_t of a 4KB page */ #define PTE_PFN_MASK ((pteval_t)PHYSICAL_PAGE_MASK) arch/x86/include/asm/pgtable.h static inline unsigned long pgd_page_vaddr(pgd_t pgd) { return (unsigned long)__va((unsigned long)pgd_val(pgd) & PTE_PFN_MASK); } /* to find an entry in a page-table-directory. */ static inline unsigned long pud_index(unsigned long address) { return (address >> PUD_SHIFT) & (PTRS_PER_PUD - 1); } static inline pud_t *pud_offset(pgd_t *pgd, unsigned long address) { return (pud_t *)pgd_page_vaddr(*pgd) + pud_index(address); } arch/x86/include/asm/page.h #define __va(x) ((void *)((unsigned long)(x)+PAGE_OFFSET)) \u5f8c\u9762\u6b65\u9a5f\u90fd\u5dee\u4e0d\u591a\uff0c\u6700\u7d42\u62ff\u5230 pte \u4e2d\u5c0d\u61c9\u6b04\u7684\u7dda\u6027\u5730\u5740\u518d\u7528 page_addr = pte_val(*pte) & PTE_PFN_MASK & PAGE_MASK; page_offset = vaddr & ~PAGE_MASK; paddr = page_addr | page_offset;","title":"Linux Paging"},{"location":"linux-kernel/others/#copy-on-write","text":"\u7576\u6211\u5011 fork() \u6642\uff0c\u6703\u7522\u751f\u4e00\u500b\u548c\u7236\u9032\u7a0b\u5b8c\u5168\u76f8\u540c\u7684\u5b50\u9032\u7a0b(\u9664\u4e86pid) \u5982\u679c\u6309\u50b3\u7d71\u7684\u505a\u6cd5\uff0c\u6703\u76f4\u63a5\u5c07\u7236\u9032\u7a0b\u7684\u6578\u64da\u62f7\u8c9d\u5230\u5b50\u9032\u7a0b\u4e2d\uff0c\u62f7\u8c9d\u5b8c\u4e4b\u5f8c\uff0c\u7236\u9032\u7a0b\u548c\u5b50\u9032\u7a0b\u4e4b\u9593\u7684 \u6578\u64da\u6bb5 \u548c \u5806\u68e7 \u662f\u76f8\u4e92\u7368\u7acb\u7684 \u4f46\u662f\uff0c\u901a\u5e38\u5b50\u9032\u7a0b\u90fd\u6703\u57f7\u884c exec() \u4f86\u505a\u81ea\u5df1\u60f3\u8981\u5be6\u73fe\u7684\u529f\u80fd\u3002 exec() exec\u51fd\u6578\u7684\u4f5c\u7528\u5c31\u662f\uff1a\u88dd\u8f09\u4e00\u500b\u65b0\u7684\u7a0b\u5e8f\uff08\u53ef\u57f7\u884c\u6620\u50cf\uff09\u8986\u84cb\u7576\u524d\u9032\u7a0b\u5167\u5b58\u7a7a\u9593\u4e2d\u7684\u6620\u50cf\uff0c\u5f9e\u800c\u57f7\u884c\u4e0d\u540c\u7684\u4efb\u52d9\u3002 exec\u7cfb\u5217\u51fd\u6578\u5728\u57f7\u884c\u6642\u6703\u76f4\u63a5\u66ff\u63db\u6389\u7576\u524d\u9032\u7a0b\u7684\u5730\u5740\u7a7a\u9593\u3002 \u6240\u4ee5\uff0c\u5982\u679c\u6309\u7167\u50b3\u7d71\u505a\u6cd5\u7684\u8a71\uff0c\u5275\u5efa\u5b50\u9032\u7a0b\u6642\u5fa9\u88fd\u904e\u53bb\u7684\u6578\u64da\u662f\u6c92\u7528\u7684(\u56e0\u70ba\u5b50\u9032\u7a0b\u57f7\u884cexec()\uff0c\u539f\u6709\u7684\u6578\u64da\u6703\u88ab\u6e05\u7a7a)\uff0c\u65e2\u7136\u5f88\u591a\u6642\u5019\u8907\u88fd\u7d66\u5b50\u9032\u7a0b\u7684\u6578\u64da\u662f\u7121\u6548\u7684\uff0c\u65bc\u662f\u5c31\u6709\u4e86Copy On Write\u9019\u9805\u6280\u8853\u4e86 fork\u5275\u5efa\u51fa\u7684\u5b50\u9032\u7a0b\uff0c\u8207\u7236\u9032\u7a0b\u5171\u4eab\u5167\u5b58\u7a7a\u9593\u3002\u4e5f\u5c31\u662f\u8aaa\uff0c\u5982\u679c\u5b50\u9032\u7a0b\u4e0d\u5c0d\u5167\u5b58\u7a7a\u9593\u9032\u884c\u5beb\u5165\u64cd\u4f5c\u7684\u8a71\uff0c\u5167\u5b58\u7a7a\u9593\u4e2d\u7684\u6578\u64da\u4e26\u4e0d\u6703\u5fa9\u5236\u7d66\u5b50\u9032\u7a0b \u4e26\u4e14\u5982\u679c\u5728fork\u51fd\u6578\u8fd4\u56de\u4e4b\u5f8c\uff0c\u5b50\u9032\u7a0b\u7b2c\u4e00\u6642\u9593 exec\u4e00\u500b\u65b0\u7684\u53ef\u57f7\u884c\u6620\u50cf\uff0c\u90a3\u9ebc\u4e5f\u4e0d\u6703\u6d6a\u8cbb\u6642\u9593\u548c\u5167\u5b58\u7a7a\u9593 \u7d50\u8ad6: \u5728fork\u4e4b\u5f8cexec\u4e4b\u524d\u5169\u500b\u9032\u7a0b\u7528\u7684\u662f\u76f8\u540c\u7684\u7269\u7406\u7a7a\u9593\uff08\u5167\u5b58\u5340\uff09\uff0c\u5b50\u9032\u7a0b\u7684\u4ee3\u78bc\u6bb5\u3001\u6578\u64da\u6bb5\u3001\u5806\u68e7\u90fd\u662f\u6307\u5411\u7236\u9032\u7a0b\u7684\u7269\u7406\u7a7a\u9593\uff0c\u4e5f\u5c31\u662f\u8aaa\uff0c \u5169\u8005\u7684\u865b\u64ec\u7a7a\u9593\u4e0d\u540c\uff0c\u4f46\u5176\u5c0d\u61c9\u7684\u7269\u7406\u7a7a\u9593\u662f\u540c\u4e00\u500b \u7576\u7236\u5b50\u9032\u7a0b\u4e2d \u6709\u66f4\u6539\u76f8\u61c9\u6bb5\u7684\u884c\u70ba\u767c\u751f\u6642\uff0c\u518d\u70ba\u5b50\u9032\u7a0b\u76f8\u61c9\u7684\u6bb5\u5206\u914d\u7269\u7406\u7a7a\u9593 \u5982\u679c\u4e0d\u662f\u56e0\u70baexec\uff0c\u5167\u6838\u6703\u7d66 \u5b50\u9032\u7a0b\u7684\u6578\u64da\u6bb5\u3001\u5806\u68e7\u6bb5\u5206\u914d\u76f8\u61c9\u7684\u7269\u7406\u7a7a\u9593 \uff08\u81f3\u6b64\u5169\u8005\u6709\u5404\u81ea\u7684\u9032\u7a0b\u7a7a\u9593\uff0c\u4e92\u4e0d\u5f71\u97ff\uff09\uff0c\u800c\u4ee3\u78bc\u6bb5\u7e7c\u7e8c\u5171\u4eab\u7236\u9032\u7a0b\u7684\u7269\u7406\u7a7a\u9593\uff08\u5169\u8005\u7684\u4ee3\u78bc\u5b8c\u5168\u76f8\u540c\uff09\u3002 \u800c\u5982\u679c\u662f\u56e0\u70baexec\uff0c\u7531\u65bc\u5169\u8005\u57f7\u884c\u7684\u4ee3\u78bc\u4e0d\u540c\uff0c\u5b50\u9032\u7a0b\u7684\u4ee3\u78bc\u6bb5\u4e5f\u6703\u5206\u914d\u55ae\u7368\u7684\u7269\u7406\u7a7a\u9593\u3002 \u5be6\u6e2c\u5f8c:(\u552f\u4e00\u5dee\u5225\u662fvirtual address\u90fd\u4e00\u6a23\uff0c\u6c92\u6709\u50cf\u4e0a\u9762\u8aaa\u7684\u90fd\u6703\u4e0d\u540c) if not write: phyiscal address same else if no exec: data, stack, heap segment different code segment same if exec: all different http://eastrivervillage.com/The-Linux-COW/","title":"copy-on-write"},{"location":"linux-kernel/others/#asmlinkage-fastcall","text":"linux \u652f\u6301\u591a\u7a2eCPU\u67b6\u69cb\uff0c\u6bd4\u5982x86\u3001ppc\u548carm\u7b49\uff0c\u5728\u4e0d\u540c\u7684\u8655\u7406\u5668\u7d50\u69cb\u4e0a\u53c3\u6578\u7684\u50b3\u905e\u65b9\u5f0f\u90fd\u4e0d\u540c\uff0c\u4f8b\u5982 x86\u7684\u51fd\u6578\u53c3\u6578\u548c\u51fd\u6578\u5167\u90e8\u5c40\u90e8\u8b8a\u91cf\u6703\u88ab\u5206\u914d\u5230\u51fd\u6578\u7684stack\u4e2d arm\u5247\u662f\u5c0d\u51fd\u6578\u8abf\u7528\u904e\u7a0b\u4e2d\u7684\u50b3\u53c3\u5b9a\u7fa9\u4e86\u4e00\u5957\u898f\u5247\uff0c\u5373ATPCS\uff0c\u898f\u5247\u4e2d\u660e\u78ba\u6307\u51faARM\u4e2dR0-R4\u90fd\u662f\u4f5c\u70ba\u901a\u7528\u5bc4\u5b58\u5668\u4f7f\u7528\uff0c\u5728\u51fd\u6578\u8abf\u7528\u6642\u8655\u7406\u5668\u5f9eR0-R4\u4e2d\u7372\u53d6\u53c3\u6578\uff0c\u5728\u51fd\u6578\u8fd4\u56de\u6642\u518d\u5c07\u9700\u8981\u8fd4\u56de\u7684\u53c3\u6578\u4e00\u6b21\u5b58\u5230R0-R4\u4e2d\uff0c\u4e5f\u5c31\u662f\u8aaa\u53ef\u4ee5\u5c07\u51fd\u6578\u53c3\u6578\u76f4\u63a5\u5b58\u653e\u5728\u5bc4\u5b58\u5668\u4e2d \u6240\u4ee5\u70ba\u4e86\u56b4\u683c\u5340\u5225\u51fd\u6578\u53c3\u6578\u7684\u5b58\u653e\u4f4d\u7f6e\uff0c\u5f15\u5165\u4e86\u5169\u500b\u6a19\u8a18 asmlinkage \u8868\u793a\u5c07\u51fd\u6578\u53c3\u6578\u5b58\u653e\u5728stack\u4e2d FASTCALL \u662f\u901a\u77e5\u7de8\u8b6f\u5668\u5c07\u51fd\u6578\u53c3\u6578\u7528\u5bc4\u5b58\u5668\u4fdd\u5b58\u8d77\u4f86 #define asmlinkage CPP_ASMLINKAGE __attribute__((regparm(0))) #define FASTCALL(x) x __attribute__((regparm(3))) #define fastcall __attribute__((regparm(3))) attribute ((regparm(0)))\uff1a\u544a\u8a34gcc\u7de8\u8b6f\u5668\u8a72\u51fd\u6578\u4e0d\u9700\u8981\u901a\u904e\u4efb\u4f55\u5bc4\u5b58\u5668\u4f86\u50b3\u905e\u53c3\u6578\uff0c\u53c3\u6578\u53ea\u662f\u901a\u904e\u5806\u68e7\u4f86\u50b3\u905e\u3002 attribute ((regparm(3)))\uff1a\u544a\u8a34gcc\u7de8\u8b6f\u5668\u9019\u500b\u51fd\u6578\u53ef\u4ee5\u901a\u904e\u5bc4\u5b58\u5668\u50b3\u905e\u591a\u90543\u500b\u7684\u53c3\u6578\uff0c\u90193\u500b\u5bc4\u5b58\u5668\u4f9d\u6b21\u70baEAX\u3001EDX\u548cECX\u3002\u66f4\u591a\u7684\u53c3\u6578\u624d\u901a\u904e\u5806\u68e7\u50b3\u905e\u3002\u9019\u6a23\u53ef\u4ee5\u6e1b\u5c11\u4e00\u4e9b\u5165\u68e7\u51fa\u68e7\u64cd\u4f5c\uff0c\u56e0\u6b64\u8abf\u7528\u6bd4\u8f03\u5feb\u3002","title":"asmlinkage | fastcall"},{"location":"linux-kernel/others/#modules","text":"buildin module obj-y += filename.o \u7de8\u8b6f\u7684\u6642\u5019\u5c31\u6703\u5728\u5c0d\u61c9\u76ee\u9304\u7522\u751fbuilt-in.o\u7684\u6a94\u6848 \u9019\u4e9b\u6a94\u6848\u4fbf\u6703\u88ab\u5305\u5165\u5728image\u88e1\u9762 externel module obj-m += filename.o \u7de8\u8b6f\u7684\u6642\u5019\u5c31\u6703\u5728\u5c0d\u61c9\u76ee\u9304\u7522\u751f kernel/time/test_udelay.ko \u7684\u6a94\u6848 \u9019\u4e9b\u6a94\u6848\u4fbf\u6703\u88ab\u653e\u7f6e\u5728 /lib/modules/$(uname -r) http://yi-jyun.blogspot.com/2017/07/linux-kernel-modules.html","title":"modules"},{"location":"linux-kernel/prepare/","text":"\u7248\u672c ubuntu 16.04 linux-kernel 4.4.1 https://mirrors.edge.kernel.org/pub/linux/kernel/v4.x/ https://elixir.bootlin.com/linux/v4.4.100/source \u74b0\u5883 \u4e0b\u8f09\u5f8c\u5148\u89e3\u58d3\u7e2e $ tar zxvf linux-3.9.1.tar.gz \u7de8\u8b6f $ cd linux-3.9.1 $ make menuconfig # or make defconfig $ make clean $ make $ make modules_install install \u7b2c\u4e00\u6b21make\u6709\u5674 error: include/linux/compiler-gcc.h:106:30: fatal error: linux/compiler-gcc5.h\uff1aNo such file or directory \u628a\u7576\u524dkernel\u539f\u78bc\u4e2d\u7684gcc\u8907\u88fd\u5230\u8981\u7de8\u8b6f\u7684kernel\u88e1\u5373\u53ef https://blog.csdn.net/u014525494/article/details/53573298 $ file arch/x86/boot/bzImage arch/x86/boot/bzImage: Linux kernel x86 boot executable bzImage, version 3.9.1 (root@eugene) #0 SMP Sun Nov 17 22:21:14 CST 2019, RO-rootFS, swap_dev 0x5, Normal VGA Enable the kernel for boot(\u96d6\u7136\u597d\u50cf\u4ed6\u6703\u81ea\u5df1\u52a0) $ sudo update-initramfs -c -k 3.19 $ sudo update-grub \u7136\u5f8c\u76f4\u63a5\u7528\u9019\u500bkernel\u958b\u6a5f\u7684\u8a71\u6703\u5361\u5728 Uncompressing Linux... done, booting the kernel. \u4e0a\u7db2\u67e5\u4e86\u4e4b\u5f8c\u767c\u73fe\u53ef\u80fd\u7684\u539f\u56e0\u4e00\u5927\u5806\uff0c\u7d22\u6027\u76f4\u63a5\u63db\u4e863.10.1\u770b\u770b\u7d50\u679c\u9084\u662f\u4e00\u6a23 \u53e6\u5916\u767c\u73fe\u5728 make install \u548c update-initramfs \u7684\u6642\u5019\u6709\u5674 amd64-microcode unsupported kernel version \u6700\u5f8c\u6539\u62104.4.1(\u672c\u4f86\u7684kernel\u662f4.4.0)\u5c31\u597d\u4e86 \u958b\u6a5f\u4e4b\u5f8c\u78ba\u5b9a\u4f7f\u7528\u7684kernel\u662f\u6211\u5011\u525b\u525b\u7de8\u7684 $ uname -a Linux eugene 4.4.1 #1 SMP Mon Nov 18 14:36:16 CST 2019 x86_64 x86_64 x86_64 GNU/Linux \u6210\u529f! \u65b0\u589e\u4e00\u500bsystem call \u5148\u5efa\u7acb\u4e00\u500b\u7a0b\u5f0f\u88e1\u9762\u6709 sys_helloworld \u7684 function $ cd linux-4.4.1/ $ mkdir mycall $ vim helloworld.c #include <linux/kernel.h> asmlinkage int sys_helloworld(void){ printk(\"hello world\"); return 0; } \u5efa\u7acbMakefile $ vim Makefile obj-y := helloworld.o \u5728\u4e3b\u8981\u7684Makefile\u4e2d\u65b0\u589emycall\u8cc7\u6599\u593e\u9032\u53bb $ cd .. $ vim Makefile core-y += kernel/ certs/ mm/ fs/ ipc/ security/ crypto/ block/ mycall/ \u5728system call table\u88e1\u65b0\u589e\u6211\u5011\u7684system call $ vim arch/x86/entry/syscalls/syscall_64.tbl 546 64 helloworld sys_helloworld # \u5728\u6700\u5f8c\u9762\u4e00\u884c\u52a0\u4e0a \u4fee\u6539 system call header $ vim include/linux/syscalls.h # \u52a0\u5728#endif\u524d asmlinkage int helloworld(void); \u7de8\u8b6f $ sudo make $ sudo make modules_install install $ reboot \u6700\u5f8c\u5beb\u4e00\u500b\u7a0b\u5f0f\u6e2c\u8a66\u4e00\u4e0b #include <stdio.h> #include <syscall.h> #include <sys/types.h> int main(){ int a = syscall(546); printf(\"system call sys_hello_world return %d\\n\", a); return 0; } $ dmesg \u6709\u770b\u5230hello world\u5c31\u4ee3\u8868\u6210\u529f\u4e86 reference: https://chybeta.github.io/2017/10/19/Linux-kernel-development-1-\u73af\u5883\u51c6\u5907/ https://www.linux.com/tutorials/how-compile-linux-kernel-0/ https://wenyuangg.github.io/posts/linux/linux-add-system-call.html https://blog.kaibro.tw/2016/11/07/Linux-Kernel\u7de8\u8b6f-Ubuntu/?fbclid=IwAR0n1xjghssrijlA7L8nFhjojsu-Wdb8w25900l_WVtvDQeJgJzv7MaXxIU","title":"\u6e96\u5099"},{"location":"linux-kernel/prepare/#_1","text":"ubuntu 16.04 linux-kernel 4.4.1 https://mirrors.edge.kernel.org/pub/linux/kernel/v4.x/ https://elixir.bootlin.com/linux/v4.4.100/source","title":"\u7248\u672c"},{"location":"linux-kernel/prepare/#_2","text":"\u4e0b\u8f09\u5f8c\u5148\u89e3\u58d3\u7e2e $ tar zxvf linux-3.9.1.tar.gz \u7de8\u8b6f $ cd linux-3.9.1 $ make menuconfig # or make defconfig $ make clean $ make $ make modules_install install \u7b2c\u4e00\u6b21make\u6709\u5674 error: include/linux/compiler-gcc.h:106:30: fatal error: linux/compiler-gcc5.h\uff1aNo such file or directory \u628a\u7576\u524dkernel\u539f\u78bc\u4e2d\u7684gcc\u8907\u88fd\u5230\u8981\u7de8\u8b6f\u7684kernel\u88e1\u5373\u53ef https://blog.csdn.net/u014525494/article/details/53573298 $ file arch/x86/boot/bzImage arch/x86/boot/bzImage: Linux kernel x86 boot executable bzImage, version 3.9.1 (root@eugene) #0 SMP Sun Nov 17 22:21:14 CST 2019, RO-rootFS, swap_dev 0x5, Normal VGA Enable the kernel for boot(\u96d6\u7136\u597d\u50cf\u4ed6\u6703\u81ea\u5df1\u52a0) $ sudo update-initramfs -c -k 3.19 $ sudo update-grub \u7136\u5f8c\u76f4\u63a5\u7528\u9019\u500bkernel\u958b\u6a5f\u7684\u8a71\u6703\u5361\u5728 Uncompressing Linux... done, booting the kernel. \u4e0a\u7db2\u67e5\u4e86\u4e4b\u5f8c\u767c\u73fe\u53ef\u80fd\u7684\u539f\u56e0\u4e00\u5927\u5806\uff0c\u7d22\u6027\u76f4\u63a5\u63db\u4e863.10.1\u770b\u770b\u7d50\u679c\u9084\u662f\u4e00\u6a23 \u53e6\u5916\u767c\u73fe\u5728 make install \u548c update-initramfs \u7684\u6642\u5019\u6709\u5674 amd64-microcode unsupported kernel version \u6700\u5f8c\u6539\u62104.4.1(\u672c\u4f86\u7684kernel\u662f4.4.0)\u5c31\u597d\u4e86 \u958b\u6a5f\u4e4b\u5f8c\u78ba\u5b9a\u4f7f\u7528\u7684kernel\u662f\u6211\u5011\u525b\u525b\u7de8\u7684 $ uname -a Linux eugene 4.4.1 #1 SMP Mon Nov 18 14:36:16 CST 2019 x86_64 x86_64 x86_64 GNU/Linux \u6210\u529f!","title":"\u74b0\u5883"},{"location":"linux-kernel/prepare/#system-call","text":"\u5148\u5efa\u7acb\u4e00\u500b\u7a0b\u5f0f\u88e1\u9762\u6709 sys_helloworld \u7684 function $ cd linux-4.4.1/ $ mkdir mycall $ vim helloworld.c #include <linux/kernel.h> asmlinkage int sys_helloworld(void){ printk(\"hello world\"); return 0; } \u5efa\u7acbMakefile $ vim Makefile obj-y := helloworld.o \u5728\u4e3b\u8981\u7684Makefile\u4e2d\u65b0\u589emycall\u8cc7\u6599\u593e\u9032\u53bb $ cd .. $ vim Makefile core-y += kernel/ certs/ mm/ fs/ ipc/ security/ crypto/ block/ mycall/ \u5728system call table\u88e1\u65b0\u589e\u6211\u5011\u7684system call $ vim arch/x86/entry/syscalls/syscall_64.tbl 546 64 helloworld sys_helloworld # \u5728\u6700\u5f8c\u9762\u4e00\u884c\u52a0\u4e0a \u4fee\u6539 system call header $ vim include/linux/syscalls.h # \u52a0\u5728#endif\u524d asmlinkage int helloworld(void); \u7de8\u8b6f $ sudo make $ sudo make modules_install install $ reboot \u6700\u5f8c\u5beb\u4e00\u500b\u7a0b\u5f0f\u6e2c\u8a66\u4e00\u4e0b #include <stdio.h> #include <syscall.h> #include <sys/types.h> int main(){ int a = syscall(546); printf(\"system call sys_hello_world return %d\\n\", a); return 0; } $ dmesg \u6709\u770b\u5230hello world\u5c31\u4ee3\u8868\u6210\u529f\u4e86 reference: https://chybeta.github.io/2017/10/19/Linux-kernel-development-1-\u73af\u5883\u51c6\u5907/ https://www.linux.com/tutorials/how-compile-linux-kernel-0/ https://wenyuangg.github.io/posts/linux/linux-add-system-call.html https://blog.kaibro.tw/2016/11/07/Linux-Kernel\u7de8\u8b6f-Ubuntu/?fbclid=IwAR0n1xjghssrijlA7L8nFhjojsu-Wdb8w25900l_WVtvDQeJgJzv7MaXxIU","title":"\u65b0\u589e\u4e00\u500bsystem call"},{"location":"linux-kernel/project-1-check/","text":"\u554f\u984c\u4e00 \u8f49\u51fa\u7684 physical address \u6709\u7684\u6703\u8d85\u5927\uff08\u524d\u9762\u591a\u4e00\u4e3280000000\uff09\uff0c\u65bc\u662f\u6211\u628a pgd_val , pud_val , pmd_val , pte_val \u90fd\u5370\u51fa\u4f86\u767c\u73fe\u53ea\u6709 pte_val \u524d\u9762\u591a\u9019\u4e00\u4e32\uff0c\u65bc\u662f\u5c31\u5148\u53bb\u770b\u4e86\u4e0b pte_offset_kernel /* * the pte page can be thought of an array like this: pte_t[PTRS_PER_PTE] * * this function returns the index of the entry in the pte page which would * control the given virtual address */ static inline unsigned long pte_index(unsigned long address) { return (address >> PAGE_SHIFT) & (PTRS_PER_PTE - 1); } static inline pte_t *pte_offset_kernel(pmd_t *pmd, unsigned long address) { return (pte_t *)pmd_page_vaddr(*pmd) + pte_index(address); } \u767c\u73fe\u5f88\u6b63\u5e38\uff0c\u548c\u4e0a\u5e7e\u5c64\u505a\u7684\u4e8b\u90fd\u4e00\u6a23\uff0c\u90a3\u770b\u770b pte_val #define pte_val(x) native_pte_val(x) static inline pteval_t native_pte_val(pte_t pte) { return pte.pte; } static inline pteval_t pte_flags(pte_t pte) { return native_pte_val(pte) & PTE_FLAGS_MASK; } \u800c\u7576\u6211\u53bb\u627e native_pte_val \u6642\u767c\u73fe\u4e0b\u9762\u6709\u4e00\u500b function pte_flags \uff0c\u4ed6\u5f9e native_pte_val \u4e2d\u53d6\u51fa flag \u7684\u90e8\u5206\uff0c\u4e5f\u96e3\u602a\u76f4\u63a5\u53d6 pte_val \u6703\u5305\u542b flag\uff0c\u6211\u5011\u9700\u8981\u628a flag \u53bb\u6389\uff0c\u6240\u4ee5\u5148\u53bb\u770b\u770b PTE_FLAGS_MASK /* Extracts the PFN from a (pte|pmd|pud|pgd)val_t of a 4KB page */ #define PTE_PFN_MASK ((pteval_t)PHYSICAL_PAGE_MASK) /* Extracts the flags from a (pte|pmd|pud|pgd)val_t of a 4KB page */ #define PTE_FLAGS_MASK (~PTE_PFN_MASK) \u770b\u5230\u9019\u908a\u5c31\u604d\u7136\u5927\u609f\uff0c\u56e0\u70ba\u6211\u5011\u6700\u5f8c\u53d6\u7269\u7406\u4f4d\u5740\u662f\u7528 pte_val(*pte) & PAGE_MASK\u3000+ vaddr & ~PAGE_MASK \u4f46\u662f\u770b\u770b\u4e0a\u9762\u5e7e\u5c64\u5728\u53d6\u5f97\u7269\u7406\u4f4d\u5740\u6642\u90fd\u662f\u7528 pxx_page_vaddr(*pxx) + index \u5176\u4e2d pxx_page_vaddr \u90fd\u662f\u5728\u505a pxx_val(*pxx) & PTE_PFN_MASK \u6211\u5011\u5c07 pte_val \u7684 flag \u6ffe\u6389\u5c31\u597d\u4e86\uff5e pte_val(*pte) & PTE_PFN_MASK & PAGE_MASK\u3000+ vaddr & ~PAGE_MASK PFN: page frame number \u554f\u984c\u4e8c \u5982\u4f55\u76f4\u63a5\u8a2a\u554f\u5be6\u9ad4\u8a18\u61b6\u9ad4\u4f4d\u5740\uff1f busybox \u4e2d\u7684 devmem \u53ef\u76f4\u63a5\u64cd\u4f5c\u7269\u7406\u5730\u5740 https://github.com/brgl/busybox/blob/master/miscutils/devmem.c \u5176\u4e2d\u4ed6\u4f7f\u7528\u5230 mmap \u548c /dev/mem \uff0c\u900f\u904e mmap \u5c07 /dev/mem \u7684\u7269\u7406\u5730\u5740\u6620\u5c04\u5230 user space\uff0c\u6211\u5011\u5c31\u53ef\u4ee5\u50cf\u64cd\u4f5c\u865b\u64ec\u5730\u5740\u822c\u8b80\u5beb Usage: devmem ADDRESS [WIDTH [VALUE]] Read/write from physical address ADDRESS Address to act upon WIDTH Width (8/16/...) VALUE Data to be written \u8981\u5be6\u4f5c\u51fa devmem \u6709\u4e09\u500b\u4e3b\u8981\u6b65\u9a5f 1 \u958b\u555f /dev/mem fd = open(\"/dev/mem\", argv[3] ? (O_RDWR | O_SYNC) : (O_RDONLY | O_SYNC)); 2 \u5c07\u7269\u7406\u5730\u5740\u900f\u904e mmap \u6620\u5c04\u5230 user space /* void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset); */ map_base = mmap(0, MAP_SIZE, argv[3] ? (PROT_READ | PROT_WRITE) : PROT_READ, MAP_SHARED, fd, target & MAP_MASK); 3 \u7b97\u51fa\u5730\u5740\u5f8c\u9032\u884c\u8b80\u5beb virt_addr = map_base + (target & MAP_MASK); // write *(*type)virt_addr = write_val // read read_val = *(*type)virt_addr \u89c0\u5bdf mmap static int mmap_mem(struct file *file, struct vm_area_struct *vma) { size_t size = vma->vm_end - vma->vm_start; phys_addr_t offset = (phys_addr_t)vma->vm_pgoff << PAGE_SHIFT; /* It's illegal to wrap around the end of the physical address space. */ if (offset + (phys_addr_t)size - 1 < offset) return -EINVAL; if (!valid_mmap_phys_addr_range(vma->vm_pgoff, size)) return -EINVAL; if (!private_mapping_ok(vma)) return -ENOSYS; if (!range_is_allowed(vma->vm_pgoff, size)) return -EPERM; if (!phys_mem_access_prot_allowed(file, vma->vm_pgoff, size, &vma->vm_page_prot)) return -EINVAL; vma->vm_page_prot = phys_mem_access_prot(file, vma->vm_pgoff, size, vma->vm_page_prot); vma->vm_ops = &mmap_mem_ops; /* Remap-pfn-range will mark the range VM_IO */ if (remap_pfn_range(vma, vma->vm_start, vma->vm_pgoff, size, vma->vm_page_prot)) { return -EAGAIN; } return 0; } 1 valid_mmap_phys_addr_range \u6aa2\u67e5\u7269\u7406\u5730\u5740\u662f\u4e0d\u662f\u5728\u7bc4\u570d\u5167 /* * Do not allow /dev/mem mappings beyond the supported physical range. */ int valid_mmap_phys_addr_range(unsigned long pfn, size_t size) { return (pfn + (size >> PAGE_SHIFT)) <= (1 + (PHYS_MASK >> PAGE_SHIFT)); } 2 private_mapping_ok \u5c0d\u65bc\u6709 MMU \u7684 CPU \u76f4\u63a5\u56de\u50b3 1(MMU\u7684\u6b0a\u9650\u7ba1\u7406\u53ef\u4ee5\u652f\u6301\u79c1\u6709\u6620\u5c04) #ifndef CONFIG_MMU ... #else static inline int private_mapping_ok(struct vm_area_struct *vma) { return 1; } #endif 3 range_is_allowed \u4ee5 frame \u70ba\u55ae\u4f4d\u6aa2\u67e5\u7269\u7406\u5730\u5740\uff0c\u6bcf\u4e00\u9801\u90fd\u547c\u53eb devmem_is_allowed \u6aa2\u67e5 #ifdef CONFIG_STRICT_DEVMEM static inline int range_is_allowed(unsigned long pfn, unsigned long size) { u64 from = ((u64)pfn) << PAGE_SHIFT; u64 to = from + size; u64 cursor = from; while (cursor < to) { if (!devmem_is_allowed(pfn)) { printk(KERN_INFO \"Program %s tried to access /dev/mem between %Lx->%Lx.\\n\", current->comm, from, to); return 0; } cursor += PAGE_SIZE; pfn++; } return 1; } #else static inline int range_is_allowed(unsigned long pfn, unsigned long size) { return 1; } #endif 3.1 devmem_is_allowed /* * devmem_is_allowed() checks to see if /dev/mem access to a certain * address is valid. The argument is a physical page number. * We mimic x86 here by disallowing access to system RAM as well as * device-exclusive MMIO regions. This effectively disable read()/write() * on /dev/mem. */ int devmem_is_allowed(unsigned long pfn) { if (iomem_is_exclusive(pfn << PAGE_SHIFT)) return 0; if (!page_is_ram(pfn)) return 1; return 0; } 3.1.1 iomem_is_exclusive \u904d\u6b77 iomem_resource\uff0c\u6aa2\u67e5\u7269\u7406\u5730\u5740\u662f\u5426\u70ba busy \u6216 exclusive #ifdef CONFIG_STRICT_DEVMEM static int strict_iomem_checks = 1; #else static int strict_iomem_checks; #endif /* * check if an address is reserved in the iomem resource tree * returns 1 if reserved, 0 if not reserved. */ int iomem_is_exclusive(u64 addr) { struct resource *p = &iomem_resource; int err = 0; loff_t l; int size = PAGE_SIZE; if (!strict_iomem_checks) return 0; addr = addr & PAGE_MASK; read_lock(&resource_lock); for (p = p->child; p ; p = r_next(NULL, p, &l)) { /* * We can probably skip the resources without * IORESOURCE_IO attribute? */ if (p->start >= addr + size) break; if (p->end < addr) continue; if (p->flags & IORESOURCE_BUSY && p->flags & IORESOURCE_EXCLUSIVE) { err = 1; break; } } read_unlock(&resource_lock); return err; } \u5c0d\u65bc\u5916\u8a2d\u7684IO\u8cc7\u6e90\uff0ckernel\u4e2d\u4f7f\u7528platform device\u6a5f\u5236\u4f86\u8a3b\u518a\u5e73\u53f0\u8a2d\u5099\uff08platform_device_register\uff09\u6642\u8abf\u7528insert_resource\u5c07\u8a72\u8a2d\u5099\u76f8\u61c9\u7684io\u8cc7\u6e90\u63d2\u5165\u5230iomem_resource\u934a\u9336\u4e2d\u3002 \u5982\u679c\u6211\u8981\u5c0d\u67d0\u5916\u8a2d\u7684IO\u8cc7\u6e90\u9032\u884c\u4fdd\u8b77\uff0c\u9632\u6b62\u7528\u6236\u7a7a\u9593\u8a2a\u554f\uff0c\u53ef\u4ee5\u5c07\u5176resource\u7684flags\u7f6e\u4f4dexclusive\u5373\u53ef\u3002 https://blog.csdn.net/skyflying2012/article/details/47611399 3.1.2 \u4e0d\u5141\u8a31\u8a2a\u554f ram \u5730\u5740 int page_is_ram(unsigned long pfn) { #ifndef CONFIG_PPC64 /* XXX for now */ return pfn < max_pfn; #else unsigned long paddr = (pfn << PAGE_SHIFT); struct memblock_region *reg; for_each_memblock(memory, reg) if (paddr >= reg->base && paddr < (reg->base + reg->size)) return 1; return 0; #endif } 4 phys_mem_access_prot_allowed \u76f4\u63a5\u56de\u50b31 5 phys_mem_access_prot \u78ba\u5b9a\u6211\u5011\u6620\u5c04\u9801\u7684\u6b0a\u9650 6 \u6700\u5f8c\u547c\u53eb remap_pfn_range \u8a2d\u5b9a paging \u7d50\u8ad6\uff1a \u5982\u679c\u6709\u958b CONFIG_STRICT_DEVMEM \u6703\u5148\u6aa2\u67e5 \u7269\u7406\u5730\u5740\u4e0d\u80fd\u8d85\u904e\u4e0a\u9650 \u4e0d\u80fd\u662fexclusive \u4e0d\u80fd\u662fram \u95dc\u9589\u7684\u8a71\u5c31\u6c92\u6709\u9650\u5236","title":"Project 1 \u6aa2\u8a0e"},{"location":"linux-kernel/project-1-check/#_1","text":"\u8f49\u51fa\u7684 physical address \u6709\u7684\u6703\u8d85\u5927\uff08\u524d\u9762\u591a\u4e00\u4e3280000000\uff09\uff0c\u65bc\u662f\u6211\u628a pgd_val , pud_val , pmd_val , pte_val \u90fd\u5370\u51fa\u4f86\u767c\u73fe\u53ea\u6709 pte_val \u524d\u9762\u591a\u9019\u4e00\u4e32\uff0c\u65bc\u662f\u5c31\u5148\u53bb\u770b\u4e86\u4e0b pte_offset_kernel /* * the pte page can be thought of an array like this: pte_t[PTRS_PER_PTE] * * this function returns the index of the entry in the pte page which would * control the given virtual address */ static inline unsigned long pte_index(unsigned long address) { return (address >> PAGE_SHIFT) & (PTRS_PER_PTE - 1); } static inline pte_t *pte_offset_kernel(pmd_t *pmd, unsigned long address) { return (pte_t *)pmd_page_vaddr(*pmd) + pte_index(address); } \u767c\u73fe\u5f88\u6b63\u5e38\uff0c\u548c\u4e0a\u5e7e\u5c64\u505a\u7684\u4e8b\u90fd\u4e00\u6a23\uff0c\u90a3\u770b\u770b pte_val #define pte_val(x) native_pte_val(x) static inline pteval_t native_pte_val(pte_t pte) { return pte.pte; } static inline pteval_t pte_flags(pte_t pte) { return native_pte_val(pte) & PTE_FLAGS_MASK; } \u800c\u7576\u6211\u53bb\u627e native_pte_val \u6642\u767c\u73fe\u4e0b\u9762\u6709\u4e00\u500b function pte_flags \uff0c\u4ed6\u5f9e native_pte_val \u4e2d\u53d6\u51fa flag \u7684\u90e8\u5206\uff0c\u4e5f\u96e3\u602a\u76f4\u63a5\u53d6 pte_val \u6703\u5305\u542b flag\uff0c\u6211\u5011\u9700\u8981\u628a flag \u53bb\u6389\uff0c\u6240\u4ee5\u5148\u53bb\u770b\u770b PTE_FLAGS_MASK /* Extracts the PFN from a (pte|pmd|pud|pgd)val_t of a 4KB page */ #define PTE_PFN_MASK ((pteval_t)PHYSICAL_PAGE_MASK) /* Extracts the flags from a (pte|pmd|pud|pgd)val_t of a 4KB page */ #define PTE_FLAGS_MASK (~PTE_PFN_MASK) \u770b\u5230\u9019\u908a\u5c31\u604d\u7136\u5927\u609f\uff0c\u56e0\u70ba\u6211\u5011\u6700\u5f8c\u53d6\u7269\u7406\u4f4d\u5740\u662f\u7528 pte_val(*pte) & PAGE_MASK\u3000+ vaddr & ~PAGE_MASK \u4f46\u662f\u770b\u770b\u4e0a\u9762\u5e7e\u5c64\u5728\u53d6\u5f97\u7269\u7406\u4f4d\u5740\u6642\u90fd\u662f\u7528 pxx_page_vaddr(*pxx) + index \u5176\u4e2d pxx_page_vaddr \u90fd\u662f\u5728\u505a pxx_val(*pxx) & PTE_PFN_MASK \u6211\u5011\u5c07 pte_val \u7684 flag \u6ffe\u6389\u5c31\u597d\u4e86\uff5e pte_val(*pte) & PTE_PFN_MASK & PAGE_MASK\u3000+ vaddr & ~PAGE_MASK PFN: page frame number","title":"\u554f\u984c\u4e00"},{"location":"linux-kernel/project-1-check/#_2","text":"\u5982\u4f55\u76f4\u63a5\u8a2a\u554f\u5be6\u9ad4\u8a18\u61b6\u9ad4\u4f4d\u5740\uff1f busybox \u4e2d\u7684 devmem \u53ef\u76f4\u63a5\u64cd\u4f5c\u7269\u7406\u5730\u5740 https://github.com/brgl/busybox/blob/master/miscutils/devmem.c \u5176\u4e2d\u4ed6\u4f7f\u7528\u5230 mmap \u548c /dev/mem \uff0c\u900f\u904e mmap \u5c07 /dev/mem \u7684\u7269\u7406\u5730\u5740\u6620\u5c04\u5230 user space\uff0c\u6211\u5011\u5c31\u53ef\u4ee5\u50cf\u64cd\u4f5c\u865b\u64ec\u5730\u5740\u822c\u8b80\u5beb Usage: devmem ADDRESS [WIDTH [VALUE]] Read/write from physical address ADDRESS Address to act upon WIDTH Width (8/16/...) VALUE Data to be written \u8981\u5be6\u4f5c\u51fa devmem \u6709\u4e09\u500b\u4e3b\u8981\u6b65\u9a5f 1 \u958b\u555f /dev/mem fd = open(\"/dev/mem\", argv[3] ? (O_RDWR | O_SYNC) : (O_RDONLY | O_SYNC)); 2 \u5c07\u7269\u7406\u5730\u5740\u900f\u904e mmap \u6620\u5c04\u5230 user space /* void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset); */ map_base = mmap(0, MAP_SIZE, argv[3] ? (PROT_READ | PROT_WRITE) : PROT_READ, MAP_SHARED, fd, target & MAP_MASK); 3 \u7b97\u51fa\u5730\u5740\u5f8c\u9032\u884c\u8b80\u5beb virt_addr = map_base + (target & MAP_MASK); // write *(*type)virt_addr = write_val // read read_val = *(*type)virt_addr","title":"\u554f\u984c\u4e8c"},{"location":"linux-kernel/project-1-check/#mmap","text":"static int mmap_mem(struct file *file, struct vm_area_struct *vma) { size_t size = vma->vm_end - vma->vm_start; phys_addr_t offset = (phys_addr_t)vma->vm_pgoff << PAGE_SHIFT; /* It's illegal to wrap around the end of the physical address space. */ if (offset + (phys_addr_t)size - 1 < offset) return -EINVAL; if (!valid_mmap_phys_addr_range(vma->vm_pgoff, size)) return -EINVAL; if (!private_mapping_ok(vma)) return -ENOSYS; if (!range_is_allowed(vma->vm_pgoff, size)) return -EPERM; if (!phys_mem_access_prot_allowed(file, vma->vm_pgoff, size, &vma->vm_page_prot)) return -EINVAL; vma->vm_page_prot = phys_mem_access_prot(file, vma->vm_pgoff, size, vma->vm_page_prot); vma->vm_ops = &mmap_mem_ops; /* Remap-pfn-range will mark the range VM_IO */ if (remap_pfn_range(vma, vma->vm_start, vma->vm_pgoff, size, vma->vm_page_prot)) { return -EAGAIN; } return 0; } 1 valid_mmap_phys_addr_range \u6aa2\u67e5\u7269\u7406\u5730\u5740\u662f\u4e0d\u662f\u5728\u7bc4\u570d\u5167 /* * Do not allow /dev/mem mappings beyond the supported physical range. */ int valid_mmap_phys_addr_range(unsigned long pfn, size_t size) { return (pfn + (size >> PAGE_SHIFT)) <= (1 + (PHYS_MASK >> PAGE_SHIFT)); } 2 private_mapping_ok \u5c0d\u65bc\u6709 MMU \u7684 CPU \u76f4\u63a5\u56de\u50b3 1(MMU\u7684\u6b0a\u9650\u7ba1\u7406\u53ef\u4ee5\u652f\u6301\u79c1\u6709\u6620\u5c04) #ifndef CONFIG_MMU ... #else static inline int private_mapping_ok(struct vm_area_struct *vma) { return 1; } #endif 3 range_is_allowed \u4ee5 frame \u70ba\u55ae\u4f4d\u6aa2\u67e5\u7269\u7406\u5730\u5740\uff0c\u6bcf\u4e00\u9801\u90fd\u547c\u53eb devmem_is_allowed \u6aa2\u67e5 #ifdef CONFIG_STRICT_DEVMEM static inline int range_is_allowed(unsigned long pfn, unsigned long size) { u64 from = ((u64)pfn) << PAGE_SHIFT; u64 to = from + size; u64 cursor = from; while (cursor < to) { if (!devmem_is_allowed(pfn)) { printk(KERN_INFO \"Program %s tried to access /dev/mem between %Lx->%Lx.\\n\", current->comm, from, to); return 0; } cursor += PAGE_SIZE; pfn++; } return 1; } #else static inline int range_is_allowed(unsigned long pfn, unsigned long size) { return 1; } #endif 3.1 devmem_is_allowed /* * devmem_is_allowed() checks to see if /dev/mem access to a certain * address is valid. The argument is a physical page number. * We mimic x86 here by disallowing access to system RAM as well as * device-exclusive MMIO regions. This effectively disable read()/write() * on /dev/mem. */ int devmem_is_allowed(unsigned long pfn) { if (iomem_is_exclusive(pfn << PAGE_SHIFT)) return 0; if (!page_is_ram(pfn)) return 1; return 0; } 3.1.1 iomem_is_exclusive \u904d\u6b77 iomem_resource\uff0c\u6aa2\u67e5\u7269\u7406\u5730\u5740\u662f\u5426\u70ba busy \u6216 exclusive #ifdef CONFIG_STRICT_DEVMEM static int strict_iomem_checks = 1; #else static int strict_iomem_checks; #endif /* * check if an address is reserved in the iomem resource tree * returns 1 if reserved, 0 if not reserved. */ int iomem_is_exclusive(u64 addr) { struct resource *p = &iomem_resource; int err = 0; loff_t l; int size = PAGE_SIZE; if (!strict_iomem_checks) return 0; addr = addr & PAGE_MASK; read_lock(&resource_lock); for (p = p->child; p ; p = r_next(NULL, p, &l)) { /* * We can probably skip the resources without * IORESOURCE_IO attribute? */ if (p->start >= addr + size) break; if (p->end < addr) continue; if (p->flags & IORESOURCE_BUSY && p->flags & IORESOURCE_EXCLUSIVE) { err = 1; break; } } read_unlock(&resource_lock); return err; } \u5c0d\u65bc\u5916\u8a2d\u7684IO\u8cc7\u6e90\uff0ckernel\u4e2d\u4f7f\u7528platform device\u6a5f\u5236\u4f86\u8a3b\u518a\u5e73\u53f0\u8a2d\u5099\uff08platform_device_register\uff09\u6642\u8abf\u7528insert_resource\u5c07\u8a72\u8a2d\u5099\u76f8\u61c9\u7684io\u8cc7\u6e90\u63d2\u5165\u5230iomem_resource\u934a\u9336\u4e2d\u3002 \u5982\u679c\u6211\u8981\u5c0d\u67d0\u5916\u8a2d\u7684IO\u8cc7\u6e90\u9032\u884c\u4fdd\u8b77\uff0c\u9632\u6b62\u7528\u6236\u7a7a\u9593\u8a2a\u554f\uff0c\u53ef\u4ee5\u5c07\u5176resource\u7684flags\u7f6e\u4f4dexclusive\u5373\u53ef\u3002 https://blog.csdn.net/skyflying2012/article/details/47611399 3.1.2 \u4e0d\u5141\u8a31\u8a2a\u554f ram \u5730\u5740 int page_is_ram(unsigned long pfn) { #ifndef CONFIG_PPC64 /* XXX for now */ return pfn < max_pfn; #else unsigned long paddr = (pfn << PAGE_SHIFT); struct memblock_region *reg; for_each_memblock(memory, reg) if (paddr >= reg->base && paddr < (reg->base + reg->size)) return 1; return 0; #endif } 4 phys_mem_access_prot_allowed \u76f4\u63a5\u56de\u50b31 5 phys_mem_access_prot \u78ba\u5b9a\u6211\u5011\u6620\u5c04\u9801\u7684\u6b0a\u9650 6 \u6700\u5f8c\u547c\u53eb remap_pfn_range \u8a2d\u5b9a paging \u7d50\u8ad6\uff1a \u5982\u679c\u6709\u958b CONFIG_STRICT_DEVMEM \u6703\u5148\u6aa2\u67e5 \u7269\u7406\u5730\u5740\u4e0d\u80fd\u8d85\u904e\u4e0a\u9650 \u4e0d\u80fd\u662fexclusive \u4e0d\u80fd\u662fram \u95dc\u9589\u7684\u8a71\u5c31\u6c92\u6709\u9650\u5236","title":"\u89c0\u5bdf mmap"},{"location":"linux-kernel/project-1/","text":"Add a new system call void linux_survey_TT(char *) to your Linux kernel so that you can call it in your program The system call has a parameter which specifies the address of a memory area that can store all information the system call collects in the kernel. The system call records the virtual address intervals consisting of the user address space of the process executing the system call. The system call records the corresponding physical address intervals used by the above virtual address intervals at the moment that you execute system call void linux_survey_TT(). Step 1 \u6211\u5011\u8981\u53d6\u5f97\u547c\u53eb\u6b64 system call \u7684 process \u7684 virtual address intervals\uff0c\u76ee\u6a19\u5c31\u662f\u53bb\u6293 current \u88e1\u9762\u7684 mm_struct \u7269\u4ef6 task_struct Linux kernel \u4e2d\u9032\u7a0b\u7528 task_struct \u7d50\u69cb\u9ad4\u8868\u793a \u9032\u7a0b\u4e3b\u8981\u7531\u4ee5\u4e0b\u5e7e\u90e8\u5206\u7d44\u6210\uff1a \u4ee3\u78bc\u6bb5\uff1a\u7de8\u8b6f\u5f8c\u5f62\u6210\u7684\u4e00\u4e9b\u6307\u4ee4 \u6578\u64da\u6bb5\uff1a\u7a0b\u5e8f\u904b\u884c\u6642\u9700\u8981\u7684\u6578\u64da \u53ea\u8b80\u6578\u64da\u6bb5\uff1a\u5e38\u91cf \u5df2\u521d\u59cb\u5316\u6578\u64da\u6bb5\uff1a\u5168\u5c40\u8b8a\u91cf\uff0c\u975c\u614b\u8b8a\u91cf \u672a\u521d\u59cb\u5316\u6578\u64da\u6bb5\uff08bss)\uff1a\u672a\u521d\u59cb\u5316\u7684\u5168\u5c40\u8b8a\u91cf\u548c\u975c\u614b\u8b8a\u91cf \u5806\u68e7\u6bb5\uff1a\u7a0b\u5e8f\u904b\u884c\u6642\u52d5\u614b\u5206\u914d\u7684\u4e00\u4e9b\u5167\u5b58 PCB\uff1a\u9032\u7a0b\u4fe1\u606f\uff0c\u72c0\u614b\u6a19\u8b58\u7b49 struct task_struct { volatile long state; //\u8fdb\u7a0b\u72b6\u6001 struct mm_struct *mm, *active_mm; //\u5185\u5b58\u5730\u5740\u7a7a\u95f4 pid_t pid; pid_t tgid; struct task_struct __rcu *real_parent; //\u771f\u6b63\u7684\u7236\u8fdb\u7a0b\uff0cfork\u65f6\u8bb0\u5f55\u7684 struct task_struct __rcu *parent; // ptrace\u540e\uff0c\u8bbe\u7f6e\u4e3atrace\u5f53\u524d\u8fdb\u7a0b\u7684\u8fdb\u7a0b struct list_head children; //\u5b50\u8fdb\u7a0b struct list_head sibling; //\u7236\u8fdb\u7a0b\u7684\u5b50\u8fdb\u7a0b\uff0c\u5373\u5144\u5f1f\u8fdb\u7a0b struct task_struct *group_leader; //\u7ebf\u7a0b\u7ec4\u7684\u9886\u5934\u7ebf\u7a0b char comm[TASK_COMM_LEN]; //\u8fdb\u7a0b\u540d\uff0c\u957f\u5ea6\u4e0a\u9650\u4e3a16\u5b57\u7b26 struct fs_struct *fs; //\u6587\u4ef6\u7cfb\u7edf\u4fe1\u606f struct files_struct *files; // \u6253\u5f00\u7684\u6587\u4ef6 struct signal_struct *signal; struct sighand_struct *sighand; struct sigpending pending; void *stack; // \u6307\u5411\u5185\u6838\u6808\u7684\u6307\u9488 ... } \u800c\u5176\u4e2dmm_struct\u9577\u9019\u6a23 struct mm_struct { struct vm_area_struct * mmap; /* list of VMAs */ struct rb_root mm_rb; unsigned long mmap_base; /* base of mmap area */ unsigned long task_size; /* size of task vm space */ pgd_t * pgd; atomic_t mm_count; /* How many references to \"struct mm_struct\" (users count as 1) */ int map_count; /* number of VMAs */ unsigned long start_code, end_code, start_data, end_data; unsigned long start_brk, brk, start_stack; unsigned long arg_start, arg_end, env_start, env_end; struct file *exe_file; /* ... some code omitted ... */ }; \u5176\u4e2d\u6709\u95dcvirtual address intervals\u7684\u8cc7\u8a0a: unsigned long start_code, end_code, start_data, end_data; unsigned long start_brk, brk, start_stack; unsigned long arg_start, arg_end, env_start, env_end; \u9019\u4e9b\u8b8a\u6578\u5b58\u7684\u662f process memory layout \u4e2d\u500b\u5340\u584a\u7684\u8d77\u59cb, \u7d50\u675f\u4f4d\u5740\uff0c\u4f8b\u5982 text segments \u5c31\u662f start_code ~ end_code struct vm_area_struct * mmap; mmap \u7d00\u9304\u9032\u7a0b\u4f7f\u7528\u5230\u7684 VMA \u5011\u5176\u4e2d vm_area_struct \u4e2d\u6bd4\u8f03\u91cd\u8981\u7684\u8cc7\u6599\u6709 unsigned long vm_start\uff1a\u8a18\u9304\u6b64 VMA \u5340\u584a\u7684\u958b\u59cb\u4f4d\u5740 unsigned long vm_end\uff1a\u8a18\u9304\u6b64 VMA \u5340\u584a\u7684\u7d50\u675f\u4f4d\u5740 struct vm_area_struct *vm_next\uff1a\u6307\u5411\u4e0b\u4e00\u500b VMA \u5340\u584a\u7d50\u69cb\u7684\u6307\u6a19 \u6211\u731c\u6240\u6709 VMA \u7684\u4f4d\u5740\u5c31\u662f process \u7684 virtual address intervals \u4e86\u5427 void my_copy(char *result, unsigned long address, size_t length){ if(copy_to_user(result, &address, length)) printk(\"error while copy_to_user\\n\"); } while(mmap->vm_next != NULL){ my_copy(result, mmap->vm_start, length); result += length; my_copy(result, mmap->vm_end, length); result += length; mmap = mmap->vm_next; } my_copy(result, state_end, length); result += length; result += length; \u9019\u908a\u5728\u505a\u7684\u4e8b\u5c31\u662f\u628a\u6bcf\u4e00\u500b vma \u7684 vm_start \u548c vm_end \u642c\u5230 result\uff0c\u642c\u904e\u53bb\u4e4b\u5f8c\u518d\u5c07 result \u5f80\u5f8c sizeof(unsigned long) \u500b bytes \u7531\u65bc\u6211\u662f\u6bcf\u500b\u5169\u500b address \u70ba\u4e00\u7d44\uff0c\u6240\u4ee5\u6700\u5f8c state_end \u6211\u4e5f\u4fdd\u7559\u5169\u500b\u8b8a\u6578\u7684\u4f4d\u5740 Step 2 \u518d\u4f86\u6211\u5011\u8981\u53d6\u5f97 corresponding physical address intervals \u7406\u89e3 linux paging \u5c31\u5f88\u597d\u627e\u4e86 #include <linux/kernel.h> #include <linux/sched.h> #include <asm/pgtable.h> static unsigned long vaddr2paddr(unsigned long vaddr){ pgd_t *pgd; pud_t *pud; pmd_t *pmd; pte_t *pte; unsigned long paddr=0, page_addr=0, page_offset=0; pgd = pgd_offset(current->mm, vaddr); if (pgd_none(*pgd)) { printk(\"not mapped in pgd\\n\"); return -1; } pud = pud_offset(pgd, vaddr); if (pud_none(*pud)) { printk(\"not mapped in pud\\n\"); return -1; } pmd = pmd_offset(pud, vaddr); if (pmd_none(*pmd)) { printk(\"not mapped in pmd\\n\"); return -1; } pte = pte_offset_kernel(pmd, vaddr); if (pte_none(*pte)) { printk(\"not mapped in pte\\n\"); return -1; } page_addr = pte_val(*pte) & PAGE_MASK; page_offset = vaddr & ~PAGE_MASK; paddr = page_addr | page_offset; return paddr; } \u900f\u904e pgd_offset , pud_offset , pmd_offset , pte_offset_kernel \u53d6\u5f97 page table\uff0c\u518d\u914d\u5408 PAGE_MASK \u53d6\u5f97 physical address\uff0c\u5176\u4e2d\u4e26\u4e0d\u662f\u6bcf\u500b virtual address \u90fd\u6709\u5206\u914d\u5230 physical address\uff0c\u6240\u4ee5\u53ef\u80fd\u5728\u53d6\u67d0\u7d1a\u5206\u9801\u6642\u767c\u751f\u53d6\u4e0d\u5230\u7684\u72c0\u6cc1\uff0c\u6b64\u6642\u6211\u5011\u5c31\u53ef\u4ee5\u5224\u65b7\u6b64 virtual address \u6c92\u6709\u88ab\u5206\u914d\u5230 mmap = mm->mmap; while(mmap->vm_next != NULL){ for(i=mmap->vm_start ; i<=mmap->vm_end ; i+=(~PAGE_MASK)+1){ unsigned long page_start = i, page_end = i+(~PAGE_MASK); unsigned long frame_start = vaddr2paddr(page_start), frame_end = vaddr2paddr(page_end); if(frame_start){ my_copy(result, page_start, length); result += length; my_copy(result, page_end, length); result += length; my_copy(result, frame_start, length); result += length; my_copy(result, frame_end, length); result += length; } } my_copy(result, vma_end, length); result += length; result += length; result += length; result += length; mmap = mmap->vm_next; } my_copy(result, state_end, length); result += length; result += length; result += length; result += length; \u7531\u65bc virtual address \u5c0d\u5230 physical address \u662f\u4ee5page\u70ba\u55ae\u4f4d\uff0c\u4e5f\u5c31\u662f\u8aaa\u4e00\u584a page \u7684\u8d77\u59cb\u4f4d\u7f6e\u6709\u5c0d\u61c9\u7684physical address \u5247\u4ee3\u8868\u6574\u584a page \u90fd\u6709\uff0c\u6240\u4ee5\u6211\u5c31\u905e\u8ff4\u904e\u6bcf\u500b vma \u4e2d\u7684\u6bcf\u500b page \u9019\u908a\u6211\u662f\u4ee5\u6bcf\u56db\u500b\u8cc7\u6599\u70ba\u4e00\u7d44(page\u982d\u5c3e+frame\u982d\u5c3e)\uff0c\u96d6\u7136\u9019\u9ebc\u591a result+=length \u6709\u9ede\u919c\u4e0d\u904e\u6211\u61f6\u5f97\u7528\u5176\u4ed6\u65b9\u6cd5\u310c Step 3 \u5217\u51fa\u547c\u53eb system call \u6642\u6709\u591a\u5c11 virtual address \u6709\u5c0d\u61c9\u7684 physical address\uff08\u5e7e\u8db4\uff09 \u6211\u9019\u908a\u6e2c\u8a66\u7aef\u6309\u7167\u525b\u525b\u7684\u5132\u5b58\u65b9\u5f0f\u6293\u51fa 1 . virtual address intervals \u9019\u6642\u53ef\u4ee5\u9806\u4fbf\u8a08\u7b97virtual address\u7e3d\u6578 int virtual_cnt = 0, physical_cnt = 0; const int length = sizeof(unsigned long); for(int i=0 ; ; i++) { unsigned long vm_start, vm_end; memcpy(&vm_start, result, length); next memcpy(&vm_end, result, length); next if(vm_start == STATE_END) break; virtual_cnt += (vm_end - vm_start); fprintf(pfile, \"vma%d: 0x%lx ~ 0x%lx\\n\", i+1, vm_start, vm_end); } 2 . physical address intervals \u9806\u4fbf\u7b97\u51faphysical address\u7e3d\u6578 fprintf(pfile, \"physical address intervals: \\n\"); for(int i=0 ; ; ){ unsigned long page_start, page_end, frame_start, frame_end; memcpy(&page_start, result, length); next memcpy(&page_end, result, length); next memcpy(&frame_start, result, length); next memcpy(&frame_end, result, length); next if(page_start == STATE_END) break; if(page_start == VMA_END){ // fprintf(pfile, \"\\n\"); continue; } physical_cnt += MASK; i++; fprintf(pfile, \"0x%lx ~ 0x%lx -> 0x%lx ~ 0x%lx\\n\", page_start, page_end, frame_start, frame_end); } \u5176\u4e2d\u6211\u9019\u908a\u628a result+=length \u66ff\u63db\u6210 next 3 . \u5370\u51fa printf(\"%s virtual addresses that have physical memory: %.2f% \\n\", filename, (double)physical_cnt/virtual_cnt*100); Step 4 \u5370\u51fa\u54ea\u4e9bvirtual address intervals\u5c0d\u61c9\u5230\u76f8\u540c\u7684physical address intervals \u9019\u88e1\u5c31\u6709\u9ede\u9ebb\u7169\u4e86\uff0c\u7531\u65bc fork() \u5f8c\u8b8a\u6210\u5169\u500bprocess\u4e0d\u80fd\u76f4\u63a5\u628a\u8cc7\u6599\u5b58\u5230\u8b8a\u6578\u4e2d(child\u5b58\u7684parent\u770b\u4e0d\u5230)\uff0c\u6240\u4ee5\u5fc5\u9808\u8981\u518d\u8b80\u6a94\u6848\u4f86\u5206\u6790 \u5148\u5ba3\u544a\u4e00\u500b struct \u4f86\u5b58\u6211\u5011\u8981\u7684\u8cc7\u6599 struct page{ unsigned long page_start; unsigned long frame_start; }; \u8b80\u6a94\u5f8c\u5b58\u5728\u9663\u5217\u4e2d void analyze_file(char *filename, struct page *pages){ FILE *pfile; pfile = fopen(filename, \"r\"); if(!pfile){ printf(\"open file error!\\n\"); return; } // \u5148\u6293\u6389\u524d\u9762\u7684vma list char useless[100]; while(fscanf(pfile, \"%[^\\n]\", useless) != EOF && strcmp(useless, \"physical address intervals: \")) fscanf(pfile, \"\\n\", useless); fscanf(pfile, \"%[^\\n]\", useless); fscanf(pfile, \"\\n\", useless); // \u6211\u5011\u8981\u7684\u8cc7\u8a0a unsigned long page_start, page_end, frame_start, frame_end; int i=0; while(fscanf(pfile, \"0x%lx ~ 0x%lx -> 0x%lx ~ 0x%lx\\n\", &page_start, &page_end, &frame_start, &frame_end) != EOF){ pages[i].page_start = page_start; pages[i].frame_start = frame_start; i++; } fclose(pfile); } \u6700\u5f8c\u518d\u5206\u5225\u62ff\u5169\u500bchild\u7684result\u505a\u6bd4\u5c0d\uff08\u6211\u5c31\u76f4\u63a5\u66b4\u529b\u4e86\uff09 void calc_phy_relation(struct page *child, struct page *parent, int num){ printf(\"\\n\\nthe virtual address intervals that map to same physical address at result_%d\\n\", num); for(int i=0 ; i<300 ; i++){ if(!child[i].page_start && !child[i].frame_start) break; for(int j=0 ; j<300 ; j++){ if(!parent[j].page_start && !parent[j].frame_start) break; if(child[i].frame_start == parent[j].frame_start){ printf(\"0x%lx ~ 0x%lx\\n\", child[i].page_start, child[i].page_start+MASK-1); break; } } } } \u5b8c\u6210\u62c9\uff5e\uff5e\u5176\u5be6\u9ebb\u7169\u7684\u90fd\u5728\u8cc7\u6599\u8655\u7406 reference: http://gityuan.com/2017/07/30/linux-process/ https://www.cnblogs.com/kwingmei/p/3731746.html https://www.cnblogs.com/Rofael/archive/2013/04/13/3019153.html https://www.ffutop.com/posts/2019-07-17-understand-kernel-13/ https://stackoverflow.com/questions/5748492/is-there-any-api-for-determining-the-physical-address-from-virtual-address-in-li http://www.jollen.org/blog/2007/01/process_vma.html","title":"Project 1"},{"location":"linux-kernel/project-1/#step-1","text":"\u6211\u5011\u8981\u53d6\u5f97\u547c\u53eb\u6b64 system call \u7684 process \u7684 virtual address intervals\uff0c\u76ee\u6a19\u5c31\u662f\u53bb\u6293 current \u88e1\u9762\u7684 mm_struct \u7269\u4ef6","title":"Step 1"},{"location":"linux-kernel/project-1/#task_struct","text":"Linux kernel \u4e2d\u9032\u7a0b\u7528 task_struct \u7d50\u69cb\u9ad4\u8868\u793a \u9032\u7a0b\u4e3b\u8981\u7531\u4ee5\u4e0b\u5e7e\u90e8\u5206\u7d44\u6210\uff1a \u4ee3\u78bc\u6bb5\uff1a\u7de8\u8b6f\u5f8c\u5f62\u6210\u7684\u4e00\u4e9b\u6307\u4ee4 \u6578\u64da\u6bb5\uff1a\u7a0b\u5e8f\u904b\u884c\u6642\u9700\u8981\u7684\u6578\u64da \u53ea\u8b80\u6578\u64da\u6bb5\uff1a\u5e38\u91cf \u5df2\u521d\u59cb\u5316\u6578\u64da\u6bb5\uff1a\u5168\u5c40\u8b8a\u91cf\uff0c\u975c\u614b\u8b8a\u91cf \u672a\u521d\u59cb\u5316\u6578\u64da\u6bb5\uff08bss)\uff1a\u672a\u521d\u59cb\u5316\u7684\u5168\u5c40\u8b8a\u91cf\u548c\u975c\u614b\u8b8a\u91cf \u5806\u68e7\u6bb5\uff1a\u7a0b\u5e8f\u904b\u884c\u6642\u52d5\u614b\u5206\u914d\u7684\u4e00\u4e9b\u5167\u5b58 PCB\uff1a\u9032\u7a0b\u4fe1\u606f\uff0c\u72c0\u614b\u6a19\u8b58\u7b49 struct task_struct { volatile long state; //\u8fdb\u7a0b\u72b6\u6001 struct mm_struct *mm, *active_mm; //\u5185\u5b58\u5730\u5740\u7a7a\u95f4 pid_t pid; pid_t tgid; struct task_struct __rcu *real_parent; //\u771f\u6b63\u7684\u7236\u8fdb\u7a0b\uff0cfork\u65f6\u8bb0\u5f55\u7684 struct task_struct __rcu *parent; // ptrace\u540e\uff0c\u8bbe\u7f6e\u4e3atrace\u5f53\u524d\u8fdb\u7a0b\u7684\u8fdb\u7a0b struct list_head children; //\u5b50\u8fdb\u7a0b struct list_head sibling; //\u7236\u8fdb\u7a0b\u7684\u5b50\u8fdb\u7a0b\uff0c\u5373\u5144\u5f1f\u8fdb\u7a0b struct task_struct *group_leader; //\u7ebf\u7a0b\u7ec4\u7684\u9886\u5934\u7ebf\u7a0b char comm[TASK_COMM_LEN]; //\u8fdb\u7a0b\u540d\uff0c\u957f\u5ea6\u4e0a\u9650\u4e3a16\u5b57\u7b26 struct fs_struct *fs; //\u6587\u4ef6\u7cfb\u7edf\u4fe1\u606f struct files_struct *files; // \u6253\u5f00\u7684\u6587\u4ef6 struct signal_struct *signal; struct sighand_struct *sighand; struct sigpending pending; void *stack; // \u6307\u5411\u5185\u6838\u6808\u7684\u6307\u9488 ... } \u800c\u5176\u4e2dmm_struct\u9577\u9019\u6a23 struct mm_struct { struct vm_area_struct * mmap; /* list of VMAs */ struct rb_root mm_rb; unsigned long mmap_base; /* base of mmap area */ unsigned long task_size; /* size of task vm space */ pgd_t * pgd; atomic_t mm_count; /* How many references to \"struct mm_struct\" (users count as 1) */ int map_count; /* number of VMAs */ unsigned long start_code, end_code, start_data, end_data; unsigned long start_brk, brk, start_stack; unsigned long arg_start, arg_end, env_start, env_end; struct file *exe_file; /* ... some code omitted ... */ }; \u5176\u4e2d\u6709\u95dcvirtual address intervals\u7684\u8cc7\u8a0a: unsigned long start_code, end_code, start_data, end_data; unsigned long start_brk, brk, start_stack; unsigned long arg_start, arg_end, env_start, env_end; \u9019\u4e9b\u8b8a\u6578\u5b58\u7684\u662f process memory layout \u4e2d\u500b\u5340\u584a\u7684\u8d77\u59cb, \u7d50\u675f\u4f4d\u5740\uff0c\u4f8b\u5982 text segments \u5c31\u662f start_code ~ end_code struct vm_area_struct * mmap; mmap \u7d00\u9304\u9032\u7a0b\u4f7f\u7528\u5230\u7684 VMA \u5011\u5176\u4e2d vm_area_struct \u4e2d\u6bd4\u8f03\u91cd\u8981\u7684\u8cc7\u6599\u6709 unsigned long vm_start\uff1a\u8a18\u9304\u6b64 VMA \u5340\u584a\u7684\u958b\u59cb\u4f4d\u5740 unsigned long vm_end\uff1a\u8a18\u9304\u6b64 VMA \u5340\u584a\u7684\u7d50\u675f\u4f4d\u5740 struct vm_area_struct *vm_next\uff1a\u6307\u5411\u4e0b\u4e00\u500b VMA \u5340\u584a\u7d50\u69cb\u7684\u6307\u6a19 \u6211\u731c\u6240\u6709 VMA \u7684\u4f4d\u5740\u5c31\u662f process \u7684 virtual address intervals \u4e86\u5427 void my_copy(char *result, unsigned long address, size_t length){ if(copy_to_user(result, &address, length)) printk(\"error while copy_to_user\\n\"); } while(mmap->vm_next != NULL){ my_copy(result, mmap->vm_start, length); result += length; my_copy(result, mmap->vm_end, length); result += length; mmap = mmap->vm_next; } my_copy(result, state_end, length); result += length; result += length; \u9019\u908a\u5728\u505a\u7684\u4e8b\u5c31\u662f\u628a\u6bcf\u4e00\u500b vma \u7684 vm_start \u548c vm_end \u642c\u5230 result\uff0c\u642c\u904e\u53bb\u4e4b\u5f8c\u518d\u5c07 result \u5f80\u5f8c sizeof(unsigned long) \u500b bytes \u7531\u65bc\u6211\u662f\u6bcf\u500b\u5169\u500b address \u70ba\u4e00\u7d44\uff0c\u6240\u4ee5\u6700\u5f8c state_end \u6211\u4e5f\u4fdd\u7559\u5169\u500b\u8b8a\u6578\u7684\u4f4d\u5740","title":"task_struct"},{"location":"linux-kernel/project-1/#step-2","text":"\u518d\u4f86\u6211\u5011\u8981\u53d6\u5f97 corresponding physical address intervals \u7406\u89e3 linux paging \u5c31\u5f88\u597d\u627e\u4e86 #include <linux/kernel.h> #include <linux/sched.h> #include <asm/pgtable.h> static unsigned long vaddr2paddr(unsigned long vaddr){ pgd_t *pgd; pud_t *pud; pmd_t *pmd; pte_t *pte; unsigned long paddr=0, page_addr=0, page_offset=0; pgd = pgd_offset(current->mm, vaddr); if (pgd_none(*pgd)) { printk(\"not mapped in pgd\\n\"); return -1; } pud = pud_offset(pgd, vaddr); if (pud_none(*pud)) { printk(\"not mapped in pud\\n\"); return -1; } pmd = pmd_offset(pud, vaddr); if (pmd_none(*pmd)) { printk(\"not mapped in pmd\\n\"); return -1; } pte = pte_offset_kernel(pmd, vaddr); if (pte_none(*pte)) { printk(\"not mapped in pte\\n\"); return -1; } page_addr = pte_val(*pte) & PAGE_MASK; page_offset = vaddr & ~PAGE_MASK; paddr = page_addr | page_offset; return paddr; } \u900f\u904e pgd_offset , pud_offset , pmd_offset , pte_offset_kernel \u53d6\u5f97 page table\uff0c\u518d\u914d\u5408 PAGE_MASK \u53d6\u5f97 physical address\uff0c\u5176\u4e2d\u4e26\u4e0d\u662f\u6bcf\u500b virtual address \u90fd\u6709\u5206\u914d\u5230 physical address\uff0c\u6240\u4ee5\u53ef\u80fd\u5728\u53d6\u67d0\u7d1a\u5206\u9801\u6642\u767c\u751f\u53d6\u4e0d\u5230\u7684\u72c0\u6cc1\uff0c\u6b64\u6642\u6211\u5011\u5c31\u53ef\u4ee5\u5224\u65b7\u6b64 virtual address \u6c92\u6709\u88ab\u5206\u914d\u5230 mmap = mm->mmap; while(mmap->vm_next != NULL){ for(i=mmap->vm_start ; i<=mmap->vm_end ; i+=(~PAGE_MASK)+1){ unsigned long page_start = i, page_end = i+(~PAGE_MASK); unsigned long frame_start = vaddr2paddr(page_start), frame_end = vaddr2paddr(page_end); if(frame_start){ my_copy(result, page_start, length); result += length; my_copy(result, page_end, length); result += length; my_copy(result, frame_start, length); result += length; my_copy(result, frame_end, length); result += length; } } my_copy(result, vma_end, length); result += length; result += length; result += length; result += length; mmap = mmap->vm_next; } my_copy(result, state_end, length); result += length; result += length; result += length; result += length; \u7531\u65bc virtual address \u5c0d\u5230 physical address \u662f\u4ee5page\u70ba\u55ae\u4f4d\uff0c\u4e5f\u5c31\u662f\u8aaa\u4e00\u584a page \u7684\u8d77\u59cb\u4f4d\u7f6e\u6709\u5c0d\u61c9\u7684physical address \u5247\u4ee3\u8868\u6574\u584a page \u90fd\u6709\uff0c\u6240\u4ee5\u6211\u5c31\u905e\u8ff4\u904e\u6bcf\u500b vma \u4e2d\u7684\u6bcf\u500b page \u9019\u908a\u6211\u662f\u4ee5\u6bcf\u56db\u500b\u8cc7\u6599\u70ba\u4e00\u7d44(page\u982d\u5c3e+frame\u982d\u5c3e)\uff0c\u96d6\u7136\u9019\u9ebc\u591a result+=length \u6709\u9ede\u919c\u4e0d\u904e\u6211\u61f6\u5f97\u7528\u5176\u4ed6\u65b9\u6cd5\u310c","title":"Step 2"},{"location":"linux-kernel/project-1/#step-3","text":"\u5217\u51fa\u547c\u53eb system call \u6642\u6709\u591a\u5c11 virtual address \u6709\u5c0d\u61c9\u7684 physical address\uff08\u5e7e\u8db4\uff09 \u6211\u9019\u908a\u6e2c\u8a66\u7aef\u6309\u7167\u525b\u525b\u7684\u5132\u5b58\u65b9\u5f0f\u6293\u51fa 1 . virtual address intervals \u9019\u6642\u53ef\u4ee5\u9806\u4fbf\u8a08\u7b97virtual address\u7e3d\u6578 int virtual_cnt = 0, physical_cnt = 0; const int length = sizeof(unsigned long); for(int i=0 ; ; i++) { unsigned long vm_start, vm_end; memcpy(&vm_start, result, length); next memcpy(&vm_end, result, length); next if(vm_start == STATE_END) break; virtual_cnt += (vm_end - vm_start); fprintf(pfile, \"vma%d: 0x%lx ~ 0x%lx\\n\", i+1, vm_start, vm_end); } 2 . physical address intervals \u9806\u4fbf\u7b97\u51faphysical address\u7e3d\u6578 fprintf(pfile, \"physical address intervals: \\n\"); for(int i=0 ; ; ){ unsigned long page_start, page_end, frame_start, frame_end; memcpy(&page_start, result, length); next memcpy(&page_end, result, length); next memcpy(&frame_start, result, length); next memcpy(&frame_end, result, length); next if(page_start == STATE_END) break; if(page_start == VMA_END){ // fprintf(pfile, \"\\n\"); continue; } physical_cnt += MASK; i++; fprintf(pfile, \"0x%lx ~ 0x%lx -> 0x%lx ~ 0x%lx\\n\", page_start, page_end, frame_start, frame_end); } \u5176\u4e2d\u6211\u9019\u908a\u628a result+=length \u66ff\u63db\u6210 next 3 . \u5370\u51fa printf(\"%s virtual addresses that have physical memory: %.2f% \\n\", filename, (double)physical_cnt/virtual_cnt*100);","title":"Step 3"},{"location":"linux-kernel/project-1/#step-4","text":"\u5370\u51fa\u54ea\u4e9bvirtual address intervals\u5c0d\u61c9\u5230\u76f8\u540c\u7684physical address intervals \u9019\u88e1\u5c31\u6709\u9ede\u9ebb\u7169\u4e86\uff0c\u7531\u65bc fork() \u5f8c\u8b8a\u6210\u5169\u500bprocess\u4e0d\u80fd\u76f4\u63a5\u628a\u8cc7\u6599\u5b58\u5230\u8b8a\u6578\u4e2d(child\u5b58\u7684parent\u770b\u4e0d\u5230)\uff0c\u6240\u4ee5\u5fc5\u9808\u8981\u518d\u8b80\u6a94\u6848\u4f86\u5206\u6790 \u5148\u5ba3\u544a\u4e00\u500b struct \u4f86\u5b58\u6211\u5011\u8981\u7684\u8cc7\u6599 struct page{ unsigned long page_start; unsigned long frame_start; }; \u8b80\u6a94\u5f8c\u5b58\u5728\u9663\u5217\u4e2d void analyze_file(char *filename, struct page *pages){ FILE *pfile; pfile = fopen(filename, \"r\"); if(!pfile){ printf(\"open file error!\\n\"); return; } // \u5148\u6293\u6389\u524d\u9762\u7684vma list char useless[100]; while(fscanf(pfile, \"%[^\\n]\", useless) != EOF && strcmp(useless, \"physical address intervals: \")) fscanf(pfile, \"\\n\", useless); fscanf(pfile, \"%[^\\n]\", useless); fscanf(pfile, \"\\n\", useless); // \u6211\u5011\u8981\u7684\u8cc7\u8a0a unsigned long page_start, page_end, frame_start, frame_end; int i=0; while(fscanf(pfile, \"0x%lx ~ 0x%lx -> 0x%lx ~ 0x%lx\\n\", &page_start, &page_end, &frame_start, &frame_end) != EOF){ pages[i].page_start = page_start; pages[i].frame_start = frame_start; i++; } fclose(pfile); } \u6700\u5f8c\u518d\u5206\u5225\u62ff\u5169\u500bchild\u7684result\u505a\u6bd4\u5c0d\uff08\u6211\u5c31\u76f4\u63a5\u66b4\u529b\u4e86\uff09 void calc_phy_relation(struct page *child, struct page *parent, int num){ printf(\"\\n\\nthe virtual address intervals that map to same physical address at result_%d\\n\", num); for(int i=0 ; i<300 ; i++){ if(!child[i].page_start && !child[i].frame_start) break; for(int j=0 ; j<300 ; j++){ if(!parent[j].page_start && !parent[j].frame_start) break; if(child[i].frame_start == parent[j].frame_start){ printf(\"0x%lx ~ 0x%lx\\n\", child[i].page_start, child[i].page_start+MASK-1); break; } } } } \u5b8c\u6210\u62c9\uff5e\uff5e\u5176\u5be6\u9ebb\u7169\u7684\u90fd\u5728\u8cc7\u6599\u8655\u7406 reference: http://gityuan.com/2017/07/30/linux-process/ https://www.cnblogs.com/kwingmei/p/3731746.html https://www.cnblogs.com/Rofael/archive/2013/04/13/3019153.html https://www.ffutop.com/posts/2019-07-17-understand-kernel-13/ https://stackoverflow.com/questions/5748492/is-there-any-api-for-determining-the-physical-address-from-virtual-address-in-li http://www.jollen.org/blog/2007/01/process_vma.html","title":"Step 4"},{"location":"linux-kernel/project2/","text":"Linux PID \u5728linux\u4e2dID\u4e3b\u8981\u6709\u4ee5\u4e0b\u56db\u7a2e: PID TGID \u5982\u679c\u4e00\u500b\u884c\u7a0b\u662f\u4ee5 CLONE_THREAD \u5efa\u7acb\uff0c\u5247\u5b83\u8655\u65bc\u4e00\u500b Thread Group\uff0cID\u5c31\u662fTGID\uff0c\u76f8\u540c\u7684Thread Group TGID\u90fd\u76f8\u540c\uff0c\u5176\u4e2dThread Group leader\u6216\u662f\u6c92\u6709\u4f7f\u7528\u57f7\u884c\u7e8c\u7684PID\u548cTGID\u76f8\u540c\u3002 PGID \u884c\u7a0b\u53ef\u4ee5\u7d44\u6210\u884c\u7a0b\u7d44\uff0cPGID\u7b49\u65bc\u7d44\u9577ID SID \u884c\u7a0b\u7d44\u4e5f\u53ef\u4ee5\u7d44\u6210 session \u70ba\u4e86\u7ba1\u7406PID linux\u4f7f\u7528\u4e86\u8a31\u591a\u6578\u64da\u7d50\u69cb\uff0c\u76f4\u63a5\u5f9e\u539f\u59cb\u78bc\u89c0\u5bdf\u6bd4\u8f03\u96e3\u7406\u89e3\uff0c\u4ee5\u4e0b\u6211\u5011\u6162\u6162\u5c07\u9700\u6c42\u52a0\u5165\u4f86\u5206\u6790 \u5ffd\u7565\u884c\u7a0b\u4e4b\u9593\u7684\u95dc\u4fc2\u53canamespace struct task_struct { ... struct pid_link pids; ... }; struct pid_link { struct hlist_node node; struct pid *pid; }; struct pid { struct hlist_head tasks; int nr; // PID struct hlist_node pid_chain; }; \u6bcf\u500b task_struct \u6709\u500b\u6307\u5411 struct pid \u7684\u6307\u6a19\uff0cstrcut pid \u5305\u542b PID pid_hash pid_map \u8003\u616e\u884c\u7a0b\u9593\u7684\u95dc\u4fc2 task_struct \u4e2d\u7684 pid_link \u591a\u52a0\u5e7e\u9805\u4f86\u53ea\u5230\u5176\u7d44\u9577\u7684 struct pid struct pid \u52a0\u4e0a\u5e7e\u9805\u4f86\u6307\u56de\u7d44\u9577\u7684 task_struct enum pid_type { PIDTYPE_PID, PIDTYPE_PGID, PIDTYPE_SID, PIDTYPE_MAX // number of ID type (not include TGID) }; struct task_struct { ... pid_t pid; pid_t tgid; struct task_struct *group_leader; // Thread group leader struct pid_link pids[PIDTYPE_MAX]; ... }; struct pid_link { struct hlist_node node; struct pid *pid; }; struct pid { struct hlist_head tasks[PIDTYPE_MAX]; int nr; int hlist_node pid_chain; } \u5047\u8a2d\u4eca\u5929\u6709\u4e09\u500b\u884c\u7a0bA B C\u5728\u540c\u4e00\u500b\u884c\u7a0b\u7d44\uff0c\u5176\u4e2dA\u662f\u884c\u7a0b\u7d44\u7d44\u9577 * B, C \u7684 pids[PIDTYPE_PFID] \u6307\u5411 A \u7684 struct pid * A \u7684 struct pid \u7684 task[PIDTYPE_PGID] \u4e32\u9023\u8d77\u6240\u6709\u4ee5\u8a72 PID \u70ba\u7d44\u9577\u7684\u7684\u884c\u7a0b\u3000 \u589e\u52a0 PID Namespace \u5728\u6bcf\u500b\u53ef\u898b\u884c\u7a0b\u7684 namespace \u90fd\u6703\u7d66\u8a72\u884c\u7a0b\u5206\u914d\u4e00\u500b PID\uff0c\u6240\u4ee5\u4e00\u500b\u884c\u7a0b\u53ef\u80fd\u6709\u591a\u500b PID struct pid{ unsigned int level; struct hlist_head tasks[PIDTYPE_MAX]; struct upid numbers[1]; } struct upid{ int nr; struct pid_namespace *ns; // pid \u6240\u8655 namespace struct hlist_node pid_chain; } numbers[0] \u8868\u793a global namespace\uff0cnumbers[i] \u8868\u793a\u7b2c i \u5c64 namespace\uff0ci \u8d8a\u5927\u6240\u5728\u5c64\u7d1a\u8d8a\u4f4e \u539f\u78bc include/linux/sched.h struct task_struct { \u00b7\u00b7\u00b7 pid_t pid; pid_t tgid; struct task_struct *group_leader; struct pid_link pids[PIDTYPE_MAX]; struct nsproxy *nsproxy; \u00b7\u00b7\u00b7 }; \u5176\u4e2d nsproxy \u5b58\u8a72\u884c\u7a0b\u76f8\u95dc namespace \u8cc7\u8a0a include/linux/nsproxy.h struct nsproxy { atomic_t count; struct uts_namespace *uts_ns; struct ipc_namespace *ipc_ns; struct mnt_namespace *mnt_ns; struct pid_namespace *pid_ns_for_children; struct net *net_ns; struct cgroup_namespace *cgroup_ns; }; include/linux/pid.h struct upid { /* Try to keep pid_chain in the same cacheline as nr for find_vpid */ int nr; struct pid_namespace *ns; struct hlist_node pid_chain; }; struct pid { atomic_t count; unsigned int level; /* lists of tasks that use this pid */ struct hlist_head tasks[PIDTYPE_MAX]; struct rcu_head rcu; struct upid numbers[1]; }; \u7b2c\u4e00\u984c Write a new system call get_process_zero_session_group(unsigned int *, int) so that a process can use it to get the global PIDs of all processes that are in the same login session of process 0 \u9019\u6b21\u7684\u984c\u76ee\u6bd4\u4e0a\u6b21\u55ae\u7d14\u8a31\u591a\uff0c\u53ea\u8981\u8dd1\u904e\u6bcf\u500b process \u7136\u5f8c\u6293\u51fa sid = 0 \u5373\u53ef asmlinkage int get_process_zero_session_group(unsigned int *result, int size){ struct task_struct *p; unsigned int ret[size]; int cnt = 0; for_each_process(p){ if( task_session(p)->numbers[0].nr == 0 && cnt < size) ret[cnt++] = task_pid(p)->numbers[0].nr; } if(copy_to_user(result, ret, sizeof(ret))) printk(\"error while copy_to_user\\n\"); return cnt; } \u7b2c\u4e8c\u984c \u7b2c\u4e8c\u984c\u662f\u8981\u62ff\u51fa\u8ddf\u547c\u53eb system call \u7684 process \u540c\u4e00\u500b session \u7684 process\uff0c\u9996\u5148\u6293\u51fa process \u7684 sid \u518d\u8dd1\u904e\u6240\u6709 process \u5373\u53ef\uff0c\u6ce8\u610f\u4e0a\u8ff0\u7684 sid \u90fd\u8981\u662f\u5728 root namespace \u7684 sid asmlinkage int get_process_session_group(unsigned int *result, int size){ struct task_struct *p; int current_sid; unsigned int ret[size]; int cnt = 0; current_sid = task_session(current)->numbers[0].nr; for_each_process(p){ if( task_session(p)->numbers[0].nr == current_sid && cnt < size ) ret[cnt++] = task_pid(p)->numbers[task_pid(p)->level].nr; } if(copy_to_user(result, ret, sizeof(ret))) printk(\"error while copy_to_user\\n\"); return cnt; } reference: https://www.cnblogs.com/hazir/p/linux_kernel_pid.html https://carecraft.github.io/basictheory/2017/03/linux-pid-manage/","title":"Project 2"},{"location":"linux-kernel/project2/#linux-pid","text":"\u5728linux\u4e2dID\u4e3b\u8981\u6709\u4ee5\u4e0b\u56db\u7a2e: PID TGID \u5982\u679c\u4e00\u500b\u884c\u7a0b\u662f\u4ee5 CLONE_THREAD \u5efa\u7acb\uff0c\u5247\u5b83\u8655\u65bc\u4e00\u500b Thread Group\uff0cID\u5c31\u662fTGID\uff0c\u76f8\u540c\u7684Thread Group TGID\u90fd\u76f8\u540c\uff0c\u5176\u4e2dThread Group leader\u6216\u662f\u6c92\u6709\u4f7f\u7528\u57f7\u884c\u7e8c\u7684PID\u548cTGID\u76f8\u540c\u3002 PGID \u884c\u7a0b\u53ef\u4ee5\u7d44\u6210\u884c\u7a0b\u7d44\uff0cPGID\u7b49\u65bc\u7d44\u9577ID SID \u884c\u7a0b\u7d44\u4e5f\u53ef\u4ee5\u7d44\u6210 session \u70ba\u4e86\u7ba1\u7406PID linux\u4f7f\u7528\u4e86\u8a31\u591a\u6578\u64da\u7d50\u69cb\uff0c\u76f4\u63a5\u5f9e\u539f\u59cb\u78bc\u89c0\u5bdf\u6bd4\u8f03\u96e3\u7406\u89e3\uff0c\u4ee5\u4e0b\u6211\u5011\u6162\u6162\u5c07\u9700\u6c42\u52a0\u5165\u4f86\u5206\u6790","title":"Linux PID"},{"location":"linux-kernel/project2/#namespace","text":"struct task_struct { ... struct pid_link pids; ... }; struct pid_link { struct hlist_node node; struct pid *pid; }; struct pid { struct hlist_head tasks; int nr; // PID struct hlist_node pid_chain; }; \u6bcf\u500b task_struct \u6709\u500b\u6307\u5411 struct pid \u7684\u6307\u6a19\uff0cstrcut pid \u5305\u542b PID pid_hash pid_map","title":"\u5ffd\u7565\u884c\u7a0b\u4e4b\u9593\u7684\u95dc\u4fc2\u53canamespace"},{"location":"linux-kernel/project2/#_1","text":"task_struct \u4e2d\u7684 pid_link \u591a\u52a0\u5e7e\u9805\u4f86\u53ea\u5230\u5176\u7d44\u9577\u7684 struct pid struct pid \u52a0\u4e0a\u5e7e\u9805\u4f86\u6307\u56de\u7d44\u9577\u7684 task_struct enum pid_type { PIDTYPE_PID, PIDTYPE_PGID, PIDTYPE_SID, PIDTYPE_MAX // number of ID type (not include TGID) }; struct task_struct { ... pid_t pid; pid_t tgid; struct task_struct *group_leader; // Thread group leader struct pid_link pids[PIDTYPE_MAX]; ... }; struct pid_link { struct hlist_node node; struct pid *pid; }; struct pid { struct hlist_head tasks[PIDTYPE_MAX]; int nr; int hlist_node pid_chain; } \u5047\u8a2d\u4eca\u5929\u6709\u4e09\u500b\u884c\u7a0bA B C\u5728\u540c\u4e00\u500b\u884c\u7a0b\u7d44\uff0c\u5176\u4e2dA\u662f\u884c\u7a0b\u7d44\u7d44\u9577 * B, C \u7684 pids[PIDTYPE_PFID] \u6307\u5411 A \u7684 struct pid * A \u7684 struct pid \u7684 task[PIDTYPE_PGID] \u4e32\u9023\u8d77\u6240\u6709\u4ee5\u8a72 PID \u70ba\u7d44\u9577\u7684\u7684\u884c\u7a0b","title":"\u8003\u616e\u884c\u7a0b\u9593\u7684\u95dc\u4fc2"},{"location":"linux-kernel/project2/#pid-namespace","text":"\u5728\u6bcf\u500b\u53ef\u898b\u884c\u7a0b\u7684 namespace \u90fd\u6703\u7d66\u8a72\u884c\u7a0b\u5206\u914d\u4e00\u500b PID\uff0c\u6240\u4ee5\u4e00\u500b\u884c\u7a0b\u53ef\u80fd\u6709\u591a\u500b PID struct pid{ unsigned int level; struct hlist_head tasks[PIDTYPE_MAX]; struct upid numbers[1]; } struct upid{ int nr; struct pid_namespace *ns; // pid \u6240\u8655 namespace struct hlist_node pid_chain; } numbers[0] \u8868\u793a global namespace\uff0cnumbers[i] \u8868\u793a\u7b2c i \u5c64 namespace\uff0ci \u8d8a\u5927\u6240\u5728\u5c64\u7d1a\u8d8a\u4f4e","title":"\u589e\u52a0 PID Namespace"},{"location":"linux-kernel/project2/#_2","text":"include/linux/sched.h struct task_struct { \u00b7\u00b7\u00b7 pid_t pid; pid_t tgid; struct task_struct *group_leader; struct pid_link pids[PIDTYPE_MAX]; struct nsproxy *nsproxy; \u00b7\u00b7\u00b7 }; \u5176\u4e2d nsproxy \u5b58\u8a72\u884c\u7a0b\u76f8\u95dc namespace \u8cc7\u8a0a include/linux/nsproxy.h struct nsproxy { atomic_t count; struct uts_namespace *uts_ns; struct ipc_namespace *ipc_ns; struct mnt_namespace *mnt_ns; struct pid_namespace *pid_ns_for_children; struct net *net_ns; struct cgroup_namespace *cgroup_ns; }; include/linux/pid.h struct upid { /* Try to keep pid_chain in the same cacheline as nr for find_vpid */ int nr; struct pid_namespace *ns; struct hlist_node pid_chain; }; struct pid { atomic_t count; unsigned int level; /* lists of tasks that use this pid */ struct hlist_head tasks[PIDTYPE_MAX]; struct rcu_head rcu; struct upid numbers[1]; };","title":"\u539f\u78bc"},{"location":"linux-kernel/project2/#_3","text":"Write a new system call get_process_zero_session_group(unsigned int *, int) so that a process can use it to get the global PIDs of all processes that are in the same login session of process 0 \u9019\u6b21\u7684\u984c\u76ee\u6bd4\u4e0a\u6b21\u55ae\u7d14\u8a31\u591a\uff0c\u53ea\u8981\u8dd1\u904e\u6bcf\u500b process \u7136\u5f8c\u6293\u51fa sid = 0 \u5373\u53ef asmlinkage int get_process_zero_session_group(unsigned int *result, int size){ struct task_struct *p; unsigned int ret[size]; int cnt = 0; for_each_process(p){ if( task_session(p)->numbers[0].nr == 0 && cnt < size) ret[cnt++] = task_pid(p)->numbers[0].nr; } if(copy_to_user(result, ret, sizeof(ret))) printk(\"error while copy_to_user\\n\"); return cnt; }","title":"\u7b2c\u4e00\u984c"},{"location":"linux-kernel/project2/#_4","text":"\u7b2c\u4e8c\u984c\u662f\u8981\u62ff\u51fa\u8ddf\u547c\u53eb system call \u7684 process \u540c\u4e00\u500b session \u7684 process\uff0c\u9996\u5148\u6293\u51fa process \u7684 sid \u518d\u8dd1\u904e\u6240\u6709 process \u5373\u53ef\uff0c\u6ce8\u610f\u4e0a\u8ff0\u7684 sid \u90fd\u8981\u662f\u5728 root namespace \u7684 sid asmlinkage int get_process_session_group(unsigned int *result, int size){ struct task_struct *p; int current_sid; unsigned int ret[size]; int cnt = 0; current_sid = task_session(current)->numbers[0].nr; for_each_process(p){ if( task_session(p)->numbers[0].nr == current_sid && cnt < size ) ret[cnt++] = task_pid(p)->numbers[task_pid(p)->level].nr; } if(copy_to_user(result, ret, sizeof(ret))) printk(\"error while copy_to_user\\n\"); return cnt; } reference: https://www.cnblogs.com/hazir/p/linux_kernel_pid.html https://carecraft.github.io/basictheory/2017/03/linux-pid-manage/","title":"\u7b2c\u4e8c\u984c"},{"location":"modern-cpp/prepare/","text":"\u7531\u65bc\u5beb\u4e86C++ \u90a3\u9ebc\u591a\u5e74\u96d6\u7136\u77e5\u9053\u6709C11, C14\u7b49\u6a19\u6e96\u6162\u6162\u88ab\u767c\u5c55\u51fa\u4f86\uff0c\u4f46\u662f\u59cb\u7d42\u6c92\u6709\u597d\u597d\u4e86\u89e3 C++ \u548c C \u4e0a\u7684\u5dee\u7570\uff0c\u6642\u5e38\u767c\u73fe\u7528C++ \u5beb\u51fa\u4f86\u7684 code \u548c C \u5dee\u4e0d\u591a\uff0c\u6240\u4ee5\u6253\u7b97\u82b1\u6bb5\u6642\u9593\u4f86\u7814\u7a76\u7814\u7a76\uff0c\u63a5\u4e0b\u4f86\u5e7e\u7bc7\u662f\u6211\u770b Modern C++ Tutorial: C++11/14/17/20 On the Fly \u7684\u7b46\u8a18 \u4f5c\u8005\u63d0\u5230\u5e0c\u671b\u6211\u5011\u4e0d\u8981\u6709 \"C++ is not a superset of C\" \u7684\u60f3\u6cd5\uff0c\u76e1\u91cf\u5728C++ \u4e2d\u907f\u514d C style \u7684\u5beb\u6cd5\uff0c\u7576\u4f60\u9700\u8981\u4f7f\u7528\u5230 C \u6642\u8981\u5c07 C code \u548c C++ code \u5206\u958b\uff0c\u4e26\u7528\u4e0d\u540c\u7684\u65b9\u5f0f\u7de8\u8b6f\u518d include Deprecated Features \u4e0d\u8a72\u5c07 string literal constant \u7d66 char* \u61c9\u8a72\u7528 auto \u6216 const char* \u4ee3\u66ff char *str = \"literal constant\" // warning noexcept \u53d6\u4ee3 unexpected_handler , set_unexpected() \u7b49 unique_ptr \u53d6\u4ee3 auto_ptr register \u53ef\u4ee5\u4f7f\u7528\u4f46\u4e0d\u518d\u6709\u4efb\u4f55\u5be6\u969b\u610f\u7fa9 \u4e0d\u80fd\u5c0d bool \u8b8a\u6578\u4f7f\u7528 ++ explicitly declaring a destructor will prevent the implicit generation of a move constructor and move assignment operator. \u81f3\u65bc\u70ba\u4ec0\u9ebc\u8981\u9019\u500b\u641e\u6211\u5011\u5f8c\u7e8c\u518d\u8a0e\u8ad6 \u4f7f\u7528 static_cast , reinterpret_cast , const_cast \u53d6\u4ee3C\u8a9e\u8a00\u98a8\u683c\u7684\u578b\u614b\u8f49\u63db ( \u5728\u8b8a\u6578\u524d\u9762\u52a0(type) ) C++17 \u4e2d\u68c4\u7528\u4e86\u4e00\u4e9b C \u51fd\u5f0f\u5eab\uff0c\u50cf\u662f <cstdbool> , <ctgmath> \u7b49 \u9084\u6709\u5f88\u591a\u5f88\u591a ... \u7576\u7136\u4f60\u9084\u662f\u53ef\u4ee5\u4f7f\u7528\u4e0a\u8ff0\u9019\u4e9b\u7279\u6027\uff0cDeprecated \u53ea\u662f\u8981\u544a\u8a34\u4f60\u9019\u4e9b\u7279\u6027\u5728\u672a\u4f86\u53ef\u80fd\u6703\u4e0d\u5728\u662f\u6a19\u6e96\uff0c\u958b\u767c\u8005\u6700\u597d\u5148\u5617\u8a66\u9069\u61c9\u6216\u6539\u8b8a\u7fd2\u6163 >< Deprecation is not completely unusable, it is only intended to imply that programmers will disappear from future standards and should be avoided. However, the deprecated features are still part of the standard library, and most of the features are actually \"permanently\" reserved for compatibility reasons. \u7de8\u8b6f $ clang++ -std=c++2a","title":"\u6e96\u5099"},{"location":"modern-cpp/prepare/#deprecated-features","text":"\u4e0d\u8a72\u5c07 string literal constant \u7d66 char* \u61c9\u8a72\u7528 auto \u6216 const char* \u4ee3\u66ff char *str = \"literal constant\" // warning noexcept \u53d6\u4ee3 unexpected_handler , set_unexpected() \u7b49 unique_ptr \u53d6\u4ee3 auto_ptr register \u53ef\u4ee5\u4f7f\u7528\u4f46\u4e0d\u518d\u6709\u4efb\u4f55\u5be6\u969b\u610f\u7fa9 \u4e0d\u80fd\u5c0d bool \u8b8a\u6578\u4f7f\u7528 ++ explicitly declaring a destructor will prevent the implicit generation of a move constructor and move assignment operator. \u81f3\u65bc\u70ba\u4ec0\u9ebc\u8981\u9019\u500b\u641e\u6211\u5011\u5f8c\u7e8c\u518d\u8a0e\u8ad6 \u4f7f\u7528 static_cast , reinterpret_cast , const_cast \u53d6\u4ee3C\u8a9e\u8a00\u98a8\u683c\u7684\u578b\u614b\u8f49\u63db ( \u5728\u8b8a\u6578\u524d\u9762\u52a0(type) ) C++17 \u4e2d\u68c4\u7528\u4e86\u4e00\u4e9b C \u51fd\u5f0f\u5eab\uff0c\u50cf\u662f <cstdbool> , <ctgmath> \u7b49 \u9084\u6709\u5f88\u591a\u5f88\u591a ... \u7576\u7136\u4f60\u9084\u662f\u53ef\u4ee5\u4f7f\u7528\u4e0a\u8ff0\u9019\u4e9b\u7279\u6027\uff0cDeprecated \u53ea\u662f\u8981\u544a\u8a34\u4f60\u9019\u4e9b\u7279\u6027\u5728\u672a\u4f86\u53ef\u80fd\u6703\u4e0d\u5728\u662f\u6a19\u6e96\uff0c\u958b\u767c\u8005\u6700\u597d\u5148\u5617\u8a66\u9069\u61c9\u6216\u6539\u8b8a\u7fd2\u6163 >< Deprecation is not completely unusable, it is only intended to imply that programmers will disappear from future standards and should be avoided. However, the deprecated features are still part of the standard library, and most of the features are actually \"permanently\" reserved for compatibility reasons.","title":"Deprecated Features"},{"location":"modern-cpp/prepare/#_1","text":"$ clang++ -std=c++2a","title":"\u7de8\u8b6f"},{"location":"modern-cpp/usability/","text":"Constant nullptr \u50b3\u7d71 C++ \u628a NULL \u7576\u6210 0 \u6216\u662f (void*)0 \uff0c\u9019\u53ef\u80fd\u6703\u767c\u751f\u5e7e\u500b\u554f\u984c NULL = (void*)0 : C++ \u4e0d\u5141\u8a31\u5c07 (void*) \u8f49\u63db\u70ba\u5176\u4ed6\u578b\u614b\uff0c\u6240\u4ee5\u4ee5\u4e0b\u7684\u7a0b\u5f0f\u6703\u6709\u554f\u984c char *str = NULL; NULL = 0 : \u96d6\u7136\u8aaa\u5c07 NULL \u5b9a\u7fa9\u6210 0 \u53ef\u4ee5\u89e3\u6c7a\u4e0a\u8ff0\u554f\u984c\uff0c\u4f46\u662f\u4f7f\u7528 overloading \u6642 void foo(char*); void foo(int); foo(NULL) \u6703\u9078\u64c7 void foo(int) \uff0c\u56e0\u70ba\u901a\u5e38\u6211\u5011\u4f7f\u7528 NULL \u90fd\u662f\u8981\u50b3\u7d66\u6307\u6a19\uff0c\u7d50\u679c\u537b\u662f\u547c\u53eb\u53c3\u6578 int \uff0c\u5341\u5206\u4e0d\u76f4\u89c0 \u70ba\u4e86\u89e3\u6c7a\u9019\u4e9b\u554f\u984c\uff0cC++11 \u5370\u5165\u4e86 nullptr \uff0c\u5176\u578b\u614b\u70ba nullptr_t \uff0c\u53ef\u4ee5\u8f49\u63db\u6210\u4efb\u4f55\u578b\u614b\u7684\u6307\u6a19 foo(0); // call foo(int) foo(NULL); // error foo(nullptr); // call foo(char*) constexpr \u5728 C++ \u4e2d\u5ba3\u544a\u9663\u5217\u6642\u53ea\u80fd\u4f7f\u7528 constant expression \u4f86\u6307\u5b9a\u9663\u5217\u5927\u5c0f\uff0c\u5373\u4f7f\u662f const \u8b8a\u6578\u4e5f\u662f\u975e\u6cd5\u7684 int len = 10; int arr[len]; //illegal const in len2 = 10; int arr2[len2]; //illegal \u4e0d\u904e\u5927\u5bb6\u4e00\u5b9a\u90fd\u7528\u904e\u4e0a\u8ff0\u7b2c\u4e8c\u7a2e\u65b9\u6cd5\u4f86\u6307\u5b9a\u9663\u5217\u5927\u5c0f\uff0c\u800c\u4e14 compiler \u4e5f\u90fd\u6c92\u6709\u5674\u904e\u932f\uff0c\u90a3\u662f\u56e0\u70ba\u5927\u591a\u6578 compiler \u90fd\u6709\u512a\u5316\uff0c\u4f7f\u5f97\u4e00\u4e9b\u4e0d\u5408\u6cd5\u7684\u5beb\u6cd5\u4e5f\u53ef\u4ee5\u88ab\u63a5\u53d7 \u5728 C++ 11 \u4e4b\u524d\u7de8\u8b6f\u5668\u7121\u6cd5\u660e\u78ba\u77e5\u9053\u8a72\u8b8a\u6578\u6216\u662f\u51fd\u6578\u56de\u50b3\u503c\u5c31\u662f\u500b\u5e38\u91cf\uff0c\u6240\u4ee5\u5728 C++11 \u4e2d\u5f15\u5165 constexpr \u9019\u500b\u95dc\u9375\u5b57\u544a\u8a34\u7de8\u8b6f\u5668\u61c9\u8a72\u53bb\u9a57\u8b49\u8a72\u8b8a\u6578\u6216\u662f\u51fd\u6578\u56de\u50b3\u503c\u5728\u7de8\u8b6f\u671f\u5c31\u662f\u4e00\u500b constant expression\uff0c\u4ee5\u4e0b\u90fd\u662f\u5408\u6cd5\u7684 constexpr int len_foo_constexpr() { return 5; } ... constexpr int len = 10; int arr[len]; constexpr int len2 = 1 + 2 + 3; int arr2[len2]; int arr3[len_foo_constexpr()]; ... constexpr \u7684\u51fd\u6578\u4e5f\u53ef\u4ee5\u7528\u65bc\u905e\u8ff4 constexpr int fibonacci(const int n) { return n == 1 || n == 2 ? 1 : fibonacci(n-1) + fibonacci(n-2); } Variables and initialization declare variable in if/switch \u5728 C++17 \u4e4b\u524d\u5982\u679c\u6211\u5011\u8981\u627e\u5230 vector \u4e2d\u7684\u7279\u5b9a\u503c\u4e26\u4fee\u6539\u4ed6 const std::vector<int>::iterator itr = std::find(vec.begin(), vec.end(), 2); if (itr != vec.end()) *itr = 3; \u9019\u500b\u5730\u65b9\u7684 itr \u53ea\u662f\u500b\u66ab\u6642\u8a18\u9304\u7528\u7684\u8b8a\u6578\uff0c\u8ddf\u4f60\u5beb for \u6642\u88e1\u9762\u6703\u7528\u5230\u7684 i \u4e00\u6a23\uff0c\u7576\u4f60\u5df2\u7d93\u50cf\u4e0a\u8ff0\u5ba3\u544a\u904e itr \uff0c for \u8ff4\u5708\u7684\u8b8a\u6578\u540d\u7a31\u5c31\u53ea\u80fd\u63db\u4e00\u500b\u7528\uff0c\u5728 C++17 \u5f8c\u6211\u5011\u53ef\u4ee5\u5728 if \u4e2d\u5ba3\u544a\u8b8a\u6578\uff0c\u8b93\u958b\u767c\u8005\u53ef\u4ee5\u514d\u53bb\u9019\u7a2e\u5c0f\u7169\u60f1 if (const std::vector<int>::iterator itr = std::find(vec.begin(), vec.end(), 3); itr != vec.end()) *itr = 4; initializer_list C++ 11 \u5f15\u5165\u65b0\u7684\u578b\u614b <initializer_list> \uff0c\u9019\u500b\u578b\u614b\u7c21\u5316\u4e86 C++ STL \u7684\u521d\u59cb\u5316\uff0c\u4ee5\u5f80\u6211\u5011\u91dd\u5c0d\u4e0d\u540c\u7684 STL \u5bb9\u5668\u7684\u521d\u59cb\u5316\u65b9\u5f0f\u90fd\u4e0d\u540c # vector 1 int arr[] = {1, 2, 3, 4, 5}; vector<int> vec(arr, arr+sizeof(arr)); # vector 2 vector<int> arr2; for(int i=1 ; i<=5 ; i++) arr2.emplace_back(i); # emplace \u5f8c\u9762\u6703\u63d0\u5230 # map map<string, string> mp; mp[\"one\"] = \"Taipei\"; mp[\"two\"] = \"Taoyuan\"; \u53ef\u4ee5\u770b\u5230\u8981\u561b\u8981\u5148\u5efa\u4e00\u500b\u9663\u5217\u8981\u561b\u4e00\u500b\u4e00\u500b\u653e\uff0c\u904b\u7528 <initializer_list> \u7684\u7279\u6027\u5c31\u7c21\u5316\u8a31\u591a vector<int> vec = {1, 2, 3, 4, 5}; map<string, string> mp = { \"one\": \"Taipei\", \"two\": \"Taoyuan\", ... } \u9664\u4e86\u521d\u59cb\u5316 container \u5916\u4e5f\u53ef\u4ee5\u7528\u4f86\u521d\u59cb\u5316\u6211\u5011\u81ea\u5df1\u5beb\u7684 class \uff0c\u6211\u5011\u53ea\u9700\u8981\u5728 class \u4e2d\u5b9a\u7fa9\u4e00\u500b\u3000 initialize list constructor class MagicFoo { public: std::vector<int> vec; MagicFoo(std::initializer_list<int> list) { for (std::initializer_list<int>::iterator it = list.begin(); it != list.end(); ++it) vec.push_back(*it); } }; ... MagicFoo = {1, 2, 3, 4, 5}; \u57fa\u672c\u4e0a\u53ea\u8981\u7528\u5230\u5927\u62ec\u865f\u8af8\u5982\u521d\u59cb\u5316\u3001\u51fd\u5f0f\u53c3\u6578\uff0c\u5c31\u6703\u81ea\u52d5\u5efa\u69cb\u4e00\u500b initialize list \uff0c\u53ef\u4ee5\u628a\u5b83\u770b\u6210\u4e00\u500b\u5e38\u91cf\uff0c\u7576\u4f60\u8907\u88fd initialize list \u4e26\u4e0d\u6703\u771f\u7684\u8907\u88fd\u800c\u662f\u5f15\u7528\u800c\u5df2\u3002 Structured binding C++ 11 \u5f8c\u5f15\u5165 <tuple> \u8b93\u6211\u5011\u53ef\u4ee5\u628a\u4e0d\u540c\u503c\u5305\u5728\u4e00\u8d77\uff0c\u4f46\u662f\u5728 C++17 \u5f8c\u624d\u80fd\u65b9\u4fbf\u7684\u4f7f\u7528\uff0c\u5982\u4e0b tuple<int, double, string> foo() { return make_tuple(1, 1.1, \"111\"); } ... auto [x, y, z] = foo(); Type inference C++ \u8ddf C \u7684\u5de8\u5927\u5340\u5225\u4e4b\u4e00\u5c31\u662f\u5f15\u5165\u4e86 auto \u548c decltype \uff0c auto \u5927\u5bb6\u90fd\u5f88\u719f\u5c31\u4e0d\u591a\u8aaa\u4e86\uff0c\u53ea\u662f\u6709\u5169\u9ede\u8981\u6ce8\u610f \u4e0d\u80fd\u7528\u4f86\u7576\u4f5c\u51fd\u5f0f\u53c3\u6578\u7684\u578b\u614b int add(auto x, auto y); // error \u4e0d\u80fd\u7528\u65bc\u5ba3\u544a\u9663\u5217 auto arr[10]; // error \u6703\u6709\u4ee5\u4e0a\u5169\u7a2e\u9650\u5236\u4e5f\u662f\u5f88\u81ea\u7136\u7684\uff0c\u4e0a\u8ff0\u72c0\u6cc1\u90fd\u6709\u95dc\u8a18\u61b6\u9ad4\u5206\u914d\uff0c\u5982\u679c\u6307\u5b9a\u70ba auto \u7a0b\u5f0f\u6703\u4e0d\u77e5\u9053\u8a72\u5206\u914d\u591a\u5c11\u5927\u5c0f\u7684\u4f4d\u5740\u3002 decltype decltype \u7528\u4f86\u8a08\u7b97\u67d0\u8868\u9054\u5f0f\u7684\u985e\u578b -> decltype(expression) auto x = 1; auto y = 2; decltype(x+y) z; \u6216\u662f\u642d\u914d is_same<T, U>::value \u5224\u65b7\u5169\u500b\u985e\u578b\u662f\u5426\u76f8\u7b49 if (is_same<decltype(x), int>::value) cout << \"type x == int\" << endl; \u53e6\u5916\u5728 C++ \u4e2d\u662f\u4e0d\u80fd\u628a\u985e\u578b\u7576\u4f5c\u53c3\u6578\u7684\uff0c\u6240\u4ee5\u5982\u679c\u4f60\u5617\u8a66\u5370\u51fa\u985e\u578b\u6703\u5674\u932f cout << decltype(x) << endl; // error \u6240\u4ee5\u5982\u679c\u4f60\u771f\u7684\u60f3\u8981\u5370\u51fa\u67d0\u500b\u8b8a\u6578\u7684\u985e\u578b\u53ef\u4ee5\u900f\u904e template template <class T> void printType(const T&){ cout << __PRETTY_FUNCTION__ << endl; } ... printType(x); // output $ void printType(const T&) [with T = int] tail type inference \u524d\u9762\u63d0\u5230\u8aaa auto \u4e0d\u80fd\u7576\u4f5c\u51fd\u5f0f\u53c3\u6578\u7684\u985e\u578b\uff0c\u90a3\u80fd\u4e0d\u80fd\u7576\u4f5c\u8fd4\u56de\u578b\u614b\u5462\uff0cC++ 14 \u5f8c\u53ef\u4ee5 template<typename T, typename U> auto add(T x, U y){ return x + y; } tail type inference \u662f\u5728 C++14 \u4e4b\u524d\u56e0\u70ba\u51fd\u6578\u4e0d\u5177\u5099\u8fd4\u56de\u503c\u63a8\u5c0e\uff0c\u6240\u4ee5\u9700\u8981\u9019\u500b\u6a5f\u5236\u4f86\u6307\u5b9a\u8fd4\u56de\u578b\u614b template<typename T, typename U> auto add(T x, U y) -> decltype(\uff58+y){ return x + y; } \u81f3\u65bc\u70ba\u4ec0\u9ebc\u4e0d\u628a\u8fd4\u56de\u578b\u614b\u5beb\u6210 decltype(\uff58+y) \u5c31\u597d\u662f\u56e0\u70ba\u8b80\u5230\u524d\u9762\u662f\u7a0b\u5f0f\u9084\u4e0d\u77e5\u9053 x \u548c y \u662f\u4ec0\u9ebc decltype(auto) ?? \u4f5c\u8005\u8868\u793a\u8981\u770b\u5b8c\u4e0b\u4e00\u7ae0\u6bd4\u8f03\u597d\u7406\u89e3","title":"Usability"},{"location":"modern-cpp/usability/#constant","text":"","title":"Constant"},{"location":"modern-cpp/usability/#nullptr","text":"\u50b3\u7d71 C++ \u628a NULL \u7576\u6210 0 \u6216\u662f (void*)0 \uff0c\u9019\u53ef\u80fd\u6703\u767c\u751f\u5e7e\u500b\u554f\u984c NULL = (void*)0 : C++ \u4e0d\u5141\u8a31\u5c07 (void*) \u8f49\u63db\u70ba\u5176\u4ed6\u578b\u614b\uff0c\u6240\u4ee5\u4ee5\u4e0b\u7684\u7a0b\u5f0f\u6703\u6709\u554f\u984c char *str = NULL; NULL = 0 : \u96d6\u7136\u8aaa\u5c07 NULL \u5b9a\u7fa9\u6210 0 \u53ef\u4ee5\u89e3\u6c7a\u4e0a\u8ff0\u554f\u984c\uff0c\u4f46\u662f\u4f7f\u7528 overloading \u6642 void foo(char*); void foo(int); foo(NULL) \u6703\u9078\u64c7 void foo(int) \uff0c\u56e0\u70ba\u901a\u5e38\u6211\u5011\u4f7f\u7528 NULL \u90fd\u662f\u8981\u50b3\u7d66\u6307\u6a19\uff0c\u7d50\u679c\u537b\u662f\u547c\u53eb\u53c3\u6578 int \uff0c\u5341\u5206\u4e0d\u76f4\u89c0 \u70ba\u4e86\u89e3\u6c7a\u9019\u4e9b\u554f\u984c\uff0cC++11 \u5370\u5165\u4e86 nullptr \uff0c\u5176\u578b\u614b\u70ba nullptr_t \uff0c\u53ef\u4ee5\u8f49\u63db\u6210\u4efb\u4f55\u578b\u614b\u7684\u6307\u6a19 foo(0); // call foo(int) foo(NULL); // error foo(nullptr); // call foo(char*)","title":"nullptr"},{"location":"modern-cpp/usability/#constexpr","text":"\u5728 C++ \u4e2d\u5ba3\u544a\u9663\u5217\u6642\u53ea\u80fd\u4f7f\u7528 constant expression \u4f86\u6307\u5b9a\u9663\u5217\u5927\u5c0f\uff0c\u5373\u4f7f\u662f const \u8b8a\u6578\u4e5f\u662f\u975e\u6cd5\u7684 int len = 10; int arr[len]; //illegal const in len2 = 10; int arr2[len2]; //illegal \u4e0d\u904e\u5927\u5bb6\u4e00\u5b9a\u90fd\u7528\u904e\u4e0a\u8ff0\u7b2c\u4e8c\u7a2e\u65b9\u6cd5\u4f86\u6307\u5b9a\u9663\u5217\u5927\u5c0f\uff0c\u800c\u4e14 compiler \u4e5f\u90fd\u6c92\u6709\u5674\u904e\u932f\uff0c\u90a3\u662f\u56e0\u70ba\u5927\u591a\u6578 compiler \u90fd\u6709\u512a\u5316\uff0c\u4f7f\u5f97\u4e00\u4e9b\u4e0d\u5408\u6cd5\u7684\u5beb\u6cd5\u4e5f\u53ef\u4ee5\u88ab\u63a5\u53d7 \u5728 C++ 11 \u4e4b\u524d\u7de8\u8b6f\u5668\u7121\u6cd5\u660e\u78ba\u77e5\u9053\u8a72\u8b8a\u6578\u6216\u662f\u51fd\u6578\u56de\u50b3\u503c\u5c31\u662f\u500b\u5e38\u91cf\uff0c\u6240\u4ee5\u5728 C++11 \u4e2d\u5f15\u5165 constexpr \u9019\u500b\u95dc\u9375\u5b57\u544a\u8a34\u7de8\u8b6f\u5668\u61c9\u8a72\u53bb\u9a57\u8b49\u8a72\u8b8a\u6578\u6216\u662f\u51fd\u6578\u56de\u50b3\u503c\u5728\u7de8\u8b6f\u671f\u5c31\u662f\u4e00\u500b constant expression\uff0c\u4ee5\u4e0b\u90fd\u662f\u5408\u6cd5\u7684 constexpr int len_foo_constexpr() { return 5; } ... constexpr int len = 10; int arr[len]; constexpr int len2 = 1 + 2 + 3; int arr2[len2]; int arr3[len_foo_constexpr()]; ... constexpr \u7684\u51fd\u6578\u4e5f\u53ef\u4ee5\u7528\u65bc\u905e\u8ff4 constexpr int fibonacci(const int n) { return n == 1 || n == 2 ? 1 : fibonacci(n-1) + fibonacci(n-2); }","title":"constexpr"},{"location":"modern-cpp/usability/#variables-and-initialization","text":"","title":"Variables and initialization"},{"location":"modern-cpp/usability/#declare-variable-in-ifswitch","text":"\u5728 C++17 \u4e4b\u524d\u5982\u679c\u6211\u5011\u8981\u627e\u5230 vector \u4e2d\u7684\u7279\u5b9a\u503c\u4e26\u4fee\u6539\u4ed6 const std::vector<int>::iterator itr = std::find(vec.begin(), vec.end(), 2); if (itr != vec.end()) *itr = 3; \u9019\u500b\u5730\u65b9\u7684 itr \u53ea\u662f\u500b\u66ab\u6642\u8a18\u9304\u7528\u7684\u8b8a\u6578\uff0c\u8ddf\u4f60\u5beb for \u6642\u88e1\u9762\u6703\u7528\u5230\u7684 i \u4e00\u6a23\uff0c\u7576\u4f60\u5df2\u7d93\u50cf\u4e0a\u8ff0\u5ba3\u544a\u904e itr \uff0c for \u8ff4\u5708\u7684\u8b8a\u6578\u540d\u7a31\u5c31\u53ea\u80fd\u63db\u4e00\u500b\u7528\uff0c\u5728 C++17 \u5f8c\u6211\u5011\u53ef\u4ee5\u5728 if \u4e2d\u5ba3\u544a\u8b8a\u6578\uff0c\u8b93\u958b\u767c\u8005\u53ef\u4ee5\u514d\u53bb\u9019\u7a2e\u5c0f\u7169\u60f1 if (const std::vector<int>::iterator itr = std::find(vec.begin(), vec.end(), 3); itr != vec.end()) *itr = 4;","title":"declare variable in if/switch"},{"location":"modern-cpp/usability/#initializer_list","text":"C++ 11 \u5f15\u5165\u65b0\u7684\u578b\u614b <initializer_list> \uff0c\u9019\u500b\u578b\u614b\u7c21\u5316\u4e86 C++ STL \u7684\u521d\u59cb\u5316\uff0c\u4ee5\u5f80\u6211\u5011\u91dd\u5c0d\u4e0d\u540c\u7684 STL \u5bb9\u5668\u7684\u521d\u59cb\u5316\u65b9\u5f0f\u90fd\u4e0d\u540c # vector 1 int arr[] = {1, 2, 3, 4, 5}; vector<int> vec(arr, arr+sizeof(arr)); # vector 2 vector<int> arr2; for(int i=1 ; i<=5 ; i++) arr2.emplace_back(i); # emplace \u5f8c\u9762\u6703\u63d0\u5230 # map map<string, string> mp; mp[\"one\"] = \"Taipei\"; mp[\"two\"] = \"Taoyuan\"; \u53ef\u4ee5\u770b\u5230\u8981\u561b\u8981\u5148\u5efa\u4e00\u500b\u9663\u5217\u8981\u561b\u4e00\u500b\u4e00\u500b\u653e\uff0c\u904b\u7528 <initializer_list> \u7684\u7279\u6027\u5c31\u7c21\u5316\u8a31\u591a vector<int> vec = {1, 2, 3, 4, 5}; map<string, string> mp = { \"one\": \"Taipei\", \"two\": \"Taoyuan\", ... } \u9664\u4e86\u521d\u59cb\u5316 container \u5916\u4e5f\u53ef\u4ee5\u7528\u4f86\u521d\u59cb\u5316\u6211\u5011\u81ea\u5df1\u5beb\u7684 class \uff0c\u6211\u5011\u53ea\u9700\u8981\u5728 class \u4e2d\u5b9a\u7fa9\u4e00\u500b\u3000 initialize list constructor class MagicFoo { public: std::vector<int> vec; MagicFoo(std::initializer_list<int> list) { for (std::initializer_list<int>::iterator it = list.begin(); it != list.end(); ++it) vec.push_back(*it); } }; ... MagicFoo = {1, 2, 3, 4, 5}; \u57fa\u672c\u4e0a\u53ea\u8981\u7528\u5230\u5927\u62ec\u865f\u8af8\u5982\u521d\u59cb\u5316\u3001\u51fd\u5f0f\u53c3\u6578\uff0c\u5c31\u6703\u81ea\u52d5\u5efa\u69cb\u4e00\u500b initialize list \uff0c\u53ef\u4ee5\u628a\u5b83\u770b\u6210\u4e00\u500b\u5e38\u91cf\uff0c\u7576\u4f60\u8907\u88fd initialize list \u4e26\u4e0d\u6703\u771f\u7684\u8907\u88fd\u800c\u662f\u5f15\u7528\u800c\u5df2\u3002","title":"initializer_list"},{"location":"modern-cpp/usability/#structured-binding","text":"C++ 11 \u5f8c\u5f15\u5165 <tuple> \u8b93\u6211\u5011\u53ef\u4ee5\u628a\u4e0d\u540c\u503c\u5305\u5728\u4e00\u8d77\uff0c\u4f46\u662f\u5728 C++17 \u5f8c\u624d\u80fd\u65b9\u4fbf\u7684\u4f7f\u7528\uff0c\u5982\u4e0b tuple<int, double, string> foo() { return make_tuple(1, 1.1, \"111\"); } ... auto [x, y, z] = foo();","title":"Structured binding"},{"location":"modern-cpp/usability/#type-inference","text":"C++ \u8ddf C \u7684\u5de8\u5927\u5340\u5225\u4e4b\u4e00\u5c31\u662f\u5f15\u5165\u4e86 auto \u548c decltype \uff0c auto \u5927\u5bb6\u90fd\u5f88\u719f\u5c31\u4e0d\u591a\u8aaa\u4e86\uff0c\u53ea\u662f\u6709\u5169\u9ede\u8981\u6ce8\u610f \u4e0d\u80fd\u7528\u4f86\u7576\u4f5c\u51fd\u5f0f\u53c3\u6578\u7684\u578b\u614b int add(auto x, auto y); // error \u4e0d\u80fd\u7528\u65bc\u5ba3\u544a\u9663\u5217 auto arr[10]; // error \u6703\u6709\u4ee5\u4e0a\u5169\u7a2e\u9650\u5236\u4e5f\u662f\u5f88\u81ea\u7136\u7684\uff0c\u4e0a\u8ff0\u72c0\u6cc1\u90fd\u6709\u95dc\u8a18\u61b6\u9ad4\u5206\u914d\uff0c\u5982\u679c\u6307\u5b9a\u70ba auto \u7a0b\u5f0f\u6703\u4e0d\u77e5\u9053\u8a72\u5206\u914d\u591a\u5c11\u5927\u5c0f\u7684\u4f4d\u5740\u3002","title":"Type inference"},{"location":"modern-cpp/usability/#decltype","text":"decltype \u7528\u4f86\u8a08\u7b97\u67d0\u8868\u9054\u5f0f\u7684\u985e\u578b -> decltype(expression) auto x = 1; auto y = 2; decltype(x+y) z; \u6216\u662f\u642d\u914d is_same<T, U>::value \u5224\u65b7\u5169\u500b\u985e\u578b\u662f\u5426\u76f8\u7b49 if (is_same<decltype(x), int>::value) cout << \"type x == int\" << endl; \u53e6\u5916\u5728 C++ \u4e2d\u662f\u4e0d\u80fd\u628a\u985e\u578b\u7576\u4f5c\u53c3\u6578\u7684\uff0c\u6240\u4ee5\u5982\u679c\u4f60\u5617\u8a66\u5370\u51fa\u985e\u578b\u6703\u5674\u932f cout << decltype(x) << endl; // error \u6240\u4ee5\u5982\u679c\u4f60\u771f\u7684\u60f3\u8981\u5370\u51fa\u67d0\u500b\u8b8a\u6578\u7684\u985e\u578b\u53ef\u4ee5\u900f\u904e template template <class T> void printType(const T&){ cout << __PRETTY_FUNCTION__ << endl; } ... printType(x); // output $ void printType(const T&) [with T = int]","title":"decltype"},{"location":"modern-cpp/usability/#tail-type-inference","text":"\u524d\u9762\u63d0\u5230\u8aaa auto \u4e0d\u80fd\u7576\u4f5c\u51fd\u5f0f\u53c3\u6578\u7684\u985e\u578b\uff0c\u90a3\u80fd\u4e0d\u80fd\u7576\u4f5c\u8fd4\u56de\u578b\u614b\u5462\uff0cC++ 14 \u5f8c\u53ef\u4ee5 template<typename T, typename U> auto add(T x, U y){ return x + y; } tail type inference \u662f\u5728 C++14 \u4e4b\u524d\u56e0\u70ba\u51fd\u6578\u4e0d\u5177\u5099\u8fd4\u56de\u503c\u63a8\u5c0e\uff0c\u6240\u4ee5\u9700\u8981\u9019\u500b\u6a5f\u5236\u4f86\u6307\u5b9a\u8fd4\u56de\u578b\u614b template<typename T, typename U> auto add(T x, U y) -> decltype(\uff58+y){ return x + y; } \u81f3\u65bc\u70ba\u4ec0\u9ebc\u4e0d\u628a\u8fd4\u56de\u578b\u614b\u5beb\u6210 decltype(\uff58+y) \u5c31\u597d\u662f\u56e0\u70ba\u8b80\u5230\u524d\u9762\u662f\u7a0b\u5f0f\u9084\u4e0d\u77e5\u9053 x \u548c y \u662f\u4ec0\u9ebc","title":"tail type inference"},{"location":"modern-cpp/usability/#decltypeauto","text":"\u4f5c\u8005\u8868\u793a\u8981\u770b\u5b8c\u4e0b\u4e00\u7ae0\u6bd4\u8f03\u597d\u7406\u89e3","title":"decltype(auto) ??"}]}